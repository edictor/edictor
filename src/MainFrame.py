# -*- coding: utf-8 -*-
# generated by wxGlade 0.5 on Tue Aug  7 19:29:21 2007 from /home/kepler/workspace/E-Dictor/src/e-dictor

# General modules
from __future__ import with_statement

import traceback, os, sys, shutil, __builtin__, subprocess, codecs, wx.html, webbrowser

from wx.lib import layoutf, dialogs
from ConfigParser import ConfigParser

# E-Dictor modules
from Graphy import *
from InsertBreakDialog import InsertBreakDialog 
from InsertTextDialog import InsertTextDialog 
from ElementPropertiesDialog import ElementPropertiesDialog 
from ExportTextDialog import ExportTextDialog 
from ExportLexDialog import ExportLexDialog 
from ExportTagsDialog import ExportTagsDialog 
from TextPropertiesDialog import TextPropertiesDialog 
from MetadataDialog import MetadataDialog 
from FindReplaceDialog import FindReplaceDialog 
from EditionReplaceDialog import EditionReplaceDialog 
from PreferencesDialog import PreferencesDialog 
from CommentsDialog import CommentsDialog 
from InsertPNDialog import InsertPNDialog 
from AboutDialog import AboutDialog 
from TestUnits import Test

from TextCtrlAutoComplete import TextCtrlAutoComplete 
# TextCtrlAutoComplete alternative
from autocomplete import *

# begin wxGlade: dependencies
# end wxGlade

# Solution to ConfigParser problem with non-ascii chars
reload(sys)
sys.setdefaultencoding('utf-8')

SESSION_ID = time.time()

ID_PROGRAM_QUIT = wx.NewId()
ID_FILE_OPEN = wx.NewId()
ID_IMAGE_OPEN = wx.NewId()
ID_FILE_SAVE = wx.NewId()
ID_FILE_SAVE_AS = wx.NewId()
ID_ED_MODE = wx.NewId()
ID_ED_PAGE_NUMBER = wx.NewId()
ID_ED_INSERT_BREAK = wx.NewId()
ID_ED_REMOVE_BK = wx.NewId()
ID_ED_REMOVE_WORD = wx.NewId()
ID_ED_INSERT_TEXT = wx.NewId()
ID_ED_MOVE_FW = wx.NewId()
ID_ED_MOVE_BACK = wx.NewId()
ID_ED_UNDO = wx.NewId()
ID_ED_REDO = wx.NewId()

ID_MENU_GRAPHY = wx.NewId()
ID_MENU_MORPHO = wx.NewId()

ID_TAB_REP = wx.NewId()
ID_TAB_GRA = wx.NewId()
ID_TAB_MOR = wx.NewId()
ID_TAB_SIN = wx.NewId()


class HtmlMessageDialog(wx.Dialog):
    def __init__(self, parent, title, message):
        wx.Dialog.__init__(self, parent, -1, title)
        html = wx.html.HtmlWindow(self, -1, size=(420, -1))
        if "gtk2" in wx.PlatformInfo:
            html.SetStandardFonts()
        html.SetPage(message)
        ir = html.GetInternalRepresentation()
        html.SetSize( (ir.GetWidth()+25, ir.GetHeight()+25) )
        self.SetClientSize(html.GetSize())
        self.CentreOnParent(wx.BOTH)


class ScrolledMessageDialog(dialogs.ScrolledMessageDialog):
    def __init__(self, parent, msg, caption,
                 pos=wx.DefaultPosition, size=(500,300),
                 style=wx.DEFAULT_DIALOG_STYLE):
        wx.Dialog.__init__(self, parent, -1, caption, pos, size, style)
        x, y = pos
        if x == -1 and y == -1:
            self.CenterOnScreen(wx.BOTH)

        html = wx.html.HtmlWindow(self, -1, size=(420, 400))
        if "gtk2" in wx.PlatformInfo:
            html.SetStandardFonts()
        html.SetPage(msg)

        ok = wx.Button(self, wx.ID_OK, "OK")
        ok.SetDefault()
        lc = layoutf.Layoutf('t=t5#1;b=t5#2;l=l5#1;r=r5#1', (self,ok))
        html.SetConstraints(lc)

        lc = layoutf.Layoutf('b=b5#1;x%w50#1;w!80;h*', (self,))
        ok.SetConstraints(lc)
        self.SetAutoLayout(1)
        self.Layout()


class MyTagHandler(wx.html.HtmlWinTagHandler):
    def __init__(self):
        wx.html.HtmlWinTagHandler.__init__(self)
        
    def GetSupportedTags(self):
        return "WORD"
        
    def HandleTag(self, tag):
        try:
            if tag.GetName() == 'WORD':
                parser = self.GetParser()
                oldlnk = parser.GetLink()
                oldclr = parser.GetActualColor()

                href = ""
                if tag.HasParam('ID'):
                    href = tag.GetParam('ID')
                parser.SetActualColor(parser.GetLinkColor())
                parser.GetContainer().InsertCell(wx.html.HtmlColourCell(parser.GetLinkColor()))
                parser.SetLink(href)

                self.ParseInner(tag)
                
                parser.SetLink(oldlnk.GetHref())
                parser.SetActualColor(oldclr)
                parser.GetContainer().InsertCell(wx.html.HtmlColourCell(oldclr))
                
                oldlnk.Destroy()
                
                return True
            else:
                return False
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            return False


class MainFrame(wx.Frame):
    def __init__(self, *args, **kwds):
    
        self._mac = wx.Platform == '__WXMAC__'
        
        # Determine if application is a script file or frozen exe
        if hasattr(sys, 'frozen'):
            __builtin__.application_path = os.path.dirname(sys.executable)
        elif __file__:
            __builtin__.application_path = os.path.dirname(__file__)

        # Read saved preferences
        if os.name in ['posix','mac']:
            __builtin__.user_data_path = os.getenv('HOME') + '/.e-dictor/'
            self.properties_file = os.getenv('HOME') + '/.e-dictor/e-dictor.properties'
        else:
            __builtin__.user_data_path = os.getenv('APPDATA') + '\E-Dictor\\'
            self.properties_file = os.getenv('APPDATA') + '\E-Dictor\e-dictor.properties'

        # Creates the app user's folder
        if not os.path.exists(os.path.dirname(self.properties_file)):
            os.mkdir(os.path.dirname(self.properties_file))

        __builtin__.log = self.log
                
        __builtin__.cfg = ConfigParser()   # Config. file available system-wide
        
        if os.path.exists(self.properties_file):
            __builtin__.cfg.read(self.properties_file)
        else:
            # Pega o arquivo de exemplo
            # __builtin__.cfg.read(__builtin__.application_path + "/res/e-dictor.properties.example")
            pass

        if not __builtin__.cfg.has_section(u'File Settings'):
            __builtin__.cfg.add_section(u'File Settings')
        
        if not __builtin__.cfg.has_option(u'File Settings', u'Recent files'):
            __builtin__.cfg.set(u'File Settings', u'Recent files', u'')

        if not __builtin__.cfg.has_section(u'Preferences'):
            __builtin__.cfg.add_section(u'Preferences')
            
        self.font_size_GRA = 3            
        if not __builtin__.cfg.has_option(u'Preferences', u'Font_size_GRA'):
            __builtin__.cfg.set(u'Preferences', u'Font_size_GRA', u'3')

        self.font_size_REP = 10            
        if not __builtin__.cfg.has_option(u'Preferences', u'Font_size_REP'):
            __builtin__.cfg.set(u'Preferences', u'Font_size_REP', u'10')

        self.recent_files = []
        if len(__builtin__.cfg.get(u'File Settings', u'Recent files')) > 0:
            self.recent_files = __builtin__.cfg.get(u'File Settings', u'Recent files').split(',')
            while '' in self.recent_files:
                self.recent_files.remove('')
        
        # Set app language
        intl.setLanguage()
        
        self.LAST_SAVE_TIME = 0
        self.test_mode = False
        self.txt_modified = False
        self.remove_list = None
        self.ed_mode = False
        self.undo_stack = []
        self.redo_stack = []
        self.prev_text_ocr = ['', 0] 
        self.toolbar_ed = [ID_ED_INSERT_BREAK, ID_ED_REMOVE_BK,
                           ID_ED_REMOVE_WORD, ID_ED_INSERT_TEXT,
                           ID_ED_MOVE_FW, ID_ED_MOVE_BACK]
        
        self.initVariables()
        
        self.MenuElements = None
        wx.html.HtmlWinParser_AddTagHandler(MyTagHandler)

        # The instance will be active throughout
        self.find_dialog = FindReplaceDialog(None)
        self.ed_repl_dialog = EditionReplaceDialog(None)
        self.ed_repl_dialog.configureDialog(self)

        # begin wxGlade: MainFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.panel_2 = wx.Panel(self, -1)
        self.notebook_1 = wx.Notebook(self, -1, style=0)
        self.notebook_1_pane_3 = wx.Panel(self.notebook_1, ID_TAB_MOR)
        self.notebook_1_pane_grafia = wx.Panel(self.notebook_1, ID_TAB_GRA)
        self.notebook_1_pane_1 = wx.Panel(self.notebook_1, ID_TAB_REP)
        self.window_1 = wx.SplitterWindow(self.notebook_1_pane_1, -1, style=wx.SP_3D|wx.SP_BORDER)
        self.window_1_pane_2 = wx.Panel(self.window_1, -1)
        self.window_1_pane_1 = wx.Panel(self.window_1, -1)
        self.sizer_81_staticbox = wx.StaticBox(self.window_1_pane_1, -1, _("Texto"))
        self.sizer_80_staticbox = wx.StaticBox(self.window_1_pane_2, -1, _(u"Fac-símile"))
        self.sizer_35_staticbox = wx.StaticBox(self.notebook_1_pane_grafia, -1, _("Propriedades"))
        self.sizer_31_staticbox = wx.StaticBox(self.notebook_1_pane_grafia, -1, _(u"Lista de edições"))
        self.sizer_13_staticbox = wx.StaticBox(self.notebook_1_pane_grafia, -1, _(u"Edição"))
        self.sizer_grafia_texto_staticbox = wx.StaticBox(self.notebook_1_pane_grafia, -1, _("Texto:"))
        self.sizer_26_staticbox = wx.StaticBox(self.notebook_1_pane_3, -1, _("Texto:"))
        self.sizer_6_staticbox = wx.StaticBox(self.panel_2, -1, "")
        self.sizer_83_staticbox = wx.StaticBox(self.notebook_1_pane_1, -1, "")
        
        # Menu Bar
        self.frame_main_menubar = wx.MenuBar()
        self.MenuProgram = wx.Menu()
        self.MenuProgramPref = wx.MenuItem(self.MenuProgram, wx.NewId(), _(u"&Preferências..."), _(u"Configuração das preferências da aplicação"), wx.ITEM_NORMAL)
        self.MenuProgram.AppendItem(self.MenuProgramPref)
        self.MenuProgram.AppendSeparator()
        self.MenuProgramTests = wx.MenuItem(self.MenuProgram, wx.NewId(), _("&Testes gerais"), "", wx.ITEM_NORMAL)
        self.MenuProgram.AppendItem(self.MenuProgramTests)
        self.MenuProgram.AppendSeparator()
        self.MenuProgramQuit = wx.MenuItem(self.MenuProgram, ID_PROGRAM_QUIT, _("&Sair\tCtrl+Q"), _("Sair do programa."), wx.ITEM_NORMAL)
        self.MenuProgram.AppendItem(self.MenuProgramQuit)
        self.frame_main_menubar.Append(self.MenuProgram, _("&Programa"))
        self.MenuFile = wx.Menu()
        self.MenuFileNew = wx.MenuItem(self.MenuFile, wx.NewId(), _("&Novo"), "", wx.ITEM_NORMAL)
        self.MenuFile.AppendItem(self.MenuFileNew)
        self.MenuFile.AppendSeparator()
        self.MenuFileOpen = wx.MenuItem(self.MenuFile, ID_FILE_OPEN, _("&Abrir\tCTRL+O"), _("Abrir um documento."), wx.ITEM_NORMAL)
        self.MenuFile.AppendItem(self.MenuFileOpen)
        self.MenuFileImageOpen = wx.MenuItem(self.MenuFile, wx.NewId(), _("Abrir imagem..."), _("Abrir arquivo de imagem"), wx.ITEM_NORMAL)
        self.MenuFile.AppendItem(self.MenuFileImageOpen)
        self.MenuFileOpenRecent = wx.Menu()
        self.MenuFileOpenRecent.Append(wx.NewId(), _("vazio"), "", wx.ITEM_NORMAL)
        self.MenuFile.AppendMenu(wx.NewId(), _("Abrir recente"), self.MenuFileOpenRecent, "")
        self.MenuFile.AppendSeparator()
        self.MenuFileSave = wx.MenuItem(self.MenuFile, ID_FILE_SAVE, _("&Salvar\tCtrl+S"), _("Salvar o documento atual."), wx.ITEM_NORMAL)
        self.MenuFile.AppendItem(self.MenuFileSave)
        self.MenuFileSaveAs = wx.MenuItem(self.MenuFile, ID_FILE_SAVE_AS, _("Salvar &como\tCTRL+SHIFT+S"), _("Salvar o documento atual usando outro nome."), wx.ITEM_NORMAL)
        self.MenuFile.AppendItem(self.MenuFileSaveAs)
        self.MenuFile.AppendSeparator()
        self.MenuFileRevert = wx.MenuItem(self.MenuFile, wx.NewId(), _("&Reverter\tF5"), "", wx.ITEM_NORMAL)
        self.MenuFile.AppendItem(self.MenuFileRevert)
        self.MenuFile.AppendSeparator()
        self.MenuFile_sub = wx.Menu()
        self.MenuFileImportXML = wx.MenuItem(self.MenuFile_sub, wx.NewId(), _("XML noutro formato..."), _(u"Tenta importar texto e edições"), wx.ITEM_NORMAL)
        self.MenuFile_sub.AppendItem(self.MenuFileImportXML)
        self.MenuFileImportWordTag = wx.MenuItem(self.MenuFile_sub, wx.NewId(), _("&Etiquetas..."), _("Importa palavras e etiquetas no formato palavra/etiqueta."), wx.ITEM_NORMAL)
        self.MenuFile_sub.AppendItem(self.MenuFileImportWordTag)
        self.MenuFile.AppendMenu(wx.NewId(), _("&Importar"), self.MenuFile_sub, "")
        self.MenuFile_sub = wx.Menu()
        self.MenuFileExportText = wx.MenuItem(self.MenuFile_sub, wx.NewId(), _("Texto..."), _("Exporta o texto em diferentes formatos."), wx.ITEM_NORMAL)
        self.MenuFile_sub.AppendItem(self.MenuFileExportText)
        self.MenuFileExportLex = wx.MenuItem(self.MenuFile_sub, wx.NewId(), _(u"Léxico de edições..."), "", wx.ITEM_NORMAL)
        self.MenuFile_sub.AppendItem(self.MenuFileExportLex)
        self.MenuFileExportTags = wx.MenuItem(self.MenuFile_sub, wx.NewId(), _(u"Sentenças etiquetadas..."), "", wx.ITEM_NORMAL)
        self.MenuFile_sub.AppendItem(self.MenuFileExportTags)
        self.MenuFile.AppendMenu(wx.NewId(), _("&Exportar"), self.MenuFile_sub, "")
        self.MenuFileClose = wx.MenuItem(self.MenuFile, wx.NewId(), _("&Fechar\tCTRL+W"), "", wx.ITEM_NORMAL)
        self.MenuFile.AppendItem(self.MenuFileClose)
        self.frame_main_menubar.Append(self.MenuFile, _("&Arquivo"))
        wxglade_tmp_menu = wx.Menu()
        self.MenuDocEdUndo = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("&Desfazer\tCTRL+Z"), _(u"Desfazer a última edição"), wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuDocEdUndo)
        self.MenuEditRedo = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("&Refazer\tCTRL+SHIFT+Z"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditRedo)
        wxglade_tmp_menu.AppendSeparator()
        self.MenuEditCut = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("Recor&tar\tCTRL+X"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditCut)
        self.MenuEditCopy = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("&Copiar\tCTRL+C"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditCopy)
        self.MenuEditPaste = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("C&olar\tCTRL+V"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditPaste)
        wxglade_tmp_menu.AppendSeparator()
        self.MenuEditSelectAll = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("Selecionar tudo\tCTRL+A"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditSelectAll)
        self.MenuEditFind = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("&Procurar/substituir...\tCTRL+F"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditFind)
        self.MenuEditFindNext = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _(u"Procurar próximo\tF3"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditFindNext)
        self.MenuEditFindPrevious = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("Procurar anterior\tSHIFT+F3"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuEditFindPrevious)
        self.frame_main_menubar.Append(wxglade_tmp_menu, _("&Editar"))
        self.MenuShow = wx.Menu()
        self.MenuShowToolbar = wx.MenuItem(self.MenuShow, wx.NewId(), _("Barra de ferramentas"), "", wx.ITEM_CHECK)
        self.MenuShow.AppendItem(self.MenuShowToolbar)
        self.MenuShow.AppendSeparator()
        self.MenuShowNextTab = wx.MenuItem(self.MenuShow, wx.NewId(), _(u"&Próxima aba\tCTRL+PAGEDOWN"), "", wx.ITEM_NORMAL)
        self.MenuShow.AppendItem(self.MenuShowNextTab)
        self.MenuShowPreviousTab = wx.MenuItem(self.MenuShow, wx.NewId(), _("&Aba anterior\tCTRL+PAGEUP"), "", wx.ITEM_NORMAL)
        self.MenuShow.AppendItem(self.MenuShowPreviousTab)
        self.MenuShow.AppendSeparator()
        self.MenuShowRaiseFont = wx.MenuItem(self.MenuShow, wx.NewId(), _("Aumentar fonte\tCTRL++"), _("Aumentar fonte do editor"), wx.ITEM_NORMAL)
        self.MenuShow.AppendItem(self.MenuShowRaiseFont)
        self.MenuShowLowFont = wx.MenuItem(self.MenuShow, wx.NewId(), _("Diminuir fonte\tCTRL+-"), _("Diminuir a fonte do editor"), wx.ITEM_NORMAL)
        self.MenuShow.AppendItem(self.MenuShowLowFont)
        self.MenuShow.AppendSeparator()
        self.MenuShowZoomIn = wx.MenuItem(self.MenuShow, wx.NewId(), _("Zoom In\tCTRL+UP"), _("Ampliar imagem"), wx.ITEM_NORMAL)
        self.MenuShow.AppendItem(self.MenuShowZoomIn)
        self.MenuShowZoomOut = wx.MenuItem(self.MenuShow, wx.NewId(), _("Zoom out\tCTRL+DOWN"), _("Diminuir tamanho da imagem exibida"), wx.ITEM_NORMAL)
        self.MenuShow.AppendItem(self.MenuShowZoomOut)
        self.frame_main_menubar.Append(self.MenuShow, _("E&xibir"))
        self.MenuDoc = wx.Menu()
        self.MenuDocTxt2XML = wx.MenuItem(self.MenuDoc, wx.NewId(), _("Gerar &XML\tCTRL+ALT+G"), _("Gerar a estrutura XML base para o texto."), wx.ITEM_NORMAL)
        self.MenuDoc.AppendItem(self.MenuDocTxt2XML)
        self.MenuDocTagging = wx.MenuItem(self.MenuDoc, wx.NewId(), _(u"Etiquetagem automática..."), _(u"Fazer etiquetagem automática do texto."), wx.ITEM_NORMAL)
        self.MenuDoc.AppendItem(self.MenuDocTagging)
        self.MenuDoc.AppendSeparator()
        self.MenuDocEdMeta = wx.MenuItem(self.MenuDoc, wx.NewId(), _("&Metadados\tCTRL+ALT+M"), "", wx.ITEM_NORMAL)
        self.MenuDoc.AppendItem(self.MenuDocEdMeta)
        self.MenuDocSelText = wx.Menu()
        self.MenuDocSelText.Append(wx.NewId(), _("default_text"), "", wx.ITEM_RADIO)
        self.MenuDoc.AppendMenu(wx.NewId(), _("&Selecionar texto"), self.MenuDocSelText, "")
        MenuDocBrowse = wx.Menu()
        if self._mac:
          self.MenuDocEdPrevWord = wx.MenuItem(MenuDocBrowse, wx.NewId(), _("Palavra anterior\tCTRL+LEFT"), _(u"Passar para palavra anterior, na edição."), wx.ITEM_NORMAL)
          MenuDocBrowse.AppendItem(self.MenuDocEdPrevWord)
          self.MenuDocEdNextWord = wx.MenuItem(MenuDocBrowse, wx.NewId(), _(u"Próxima palavra\tCTRL+RIGHT"), _(u"Passar para próxima palavra, na edição."), wx.ITEM_NORMAL)
          MenuDocBrowse.AppendItem(self.MenuDocEdNextWord)
        else:
          self.MenuDocEdPrevWord = wx.MenuItem(MenuDocBrowse, wx.NewId(), _("Palavra anterior\tCTRL+SHIFT+SPACE"), _(u"Passar para palavra anterior, na edição."), wx.ITEM_NORMAL)
          MenuDocBrowse.AppendItem(self.MenuDocEdPrevWord)
          self.MenuDocEdNextWord = wx.MenuItem(MenuDocBrowse, wx.NewId(), _(u"Próxima palavra\tCTRL+SPACE"), _(u"Passar para próxima palavra, na edição."), wx.ITEM_NORMAL)
          MenuDocBrowse.AppendItem(self.MenuDocEdNextWord)
        MenuDocBrowse.AppendSeparator()
        self.MenuDocEdPrevPage = wx.MenuItem(MenuDocBrowse, wx.NewId(), _(u"Página &anterior"), _(u"Exibe a página anterior"), wx.ITEM_NORMAL)
        MenuDocBrowse.AppendItem(self.MenuDocEdPrevPage)
        self.MenuDocEdNextPage = wx.MenuItem(MenuDocBrowse, wx.NewId(), _(u"Página &seguinte"), _(u"Exibe a próxima página"), wx.ITEM_NORMAL)
        MenuDocBrowse.AppendItem(self.MenuDocEdNextPage)
        self.MenuDocEdFirstPage = wx.MenuItem(MenuDocBrowse, wx.NewId(), _(u"Página &inicial"), _(u"Exibe a primeira página"), wx.ITEM_NORMAL)
        MenuDocBrowse.AppendItem(self.MenuDocEdFirstPage)
        self.MenuDocEdLastPage = wx.MenuItem(MenuDocBrowse, wx.NewId(), _(u"Página &final"), _(u"Exibe a página final"), wx.ITEM_NORMAL)
        MenuDocBrowse.AppendItem(self.MenuDocEdLastPage)
        self.MenuDoc.AppendMenu(wx.NewId(), _(u"&Navegação"), MenuDocBrowse, "")
        self.frame_main_menubar.Append(self.MenuDoc, _("Do&cumento"))
        self.MenuDocEdition = wx.Menu()
        self.MenuDocEdition_sub = wx.Menu()
        self.MenuDocEdTextProperties = wx.MenuItem(self.MenuDocEdition_sub, wx.NewId(), _("&Propriedades..."), _("Editar propriedades do texto"), wx.ITEM_NORMAL)
        self.MenuDocEdition_sub.AppendItem(self.MenuDocEdTextProperties)
        self.MenuDocComment = wx.MenuItem(self.MenuDocEdition_sub, wx.NewId(), _(u"&Comentários"), _(u"Comentários gerais sobre o texto"), wx.ITEM_NORMAL)
        self.MenuDocEdition_sub.AppendItem(self.MenuDocComment)
        self.MenuDocEdition_sub.AppendSeparator()
        self.MenuDocEdTextRemove = wx.MenuItem(self.MenuDocEdition_sub, wx.NewId(), _("&Excluir do documento"), "", wx.ITEM_NORMAL)
        self.MenuDocEdition_sub.AppendItem(self.MenuDocEdTextRemove)
        self.MenuDocEdition.AppendMenu(wx.NewId(), _("Texto"), self.MenuDocEdition_sub, "")
        self.MenuDocEdition.AppendSeparator()
        self.MenuDocEdHeadFoot = wx.MenuItem(self.MenuDocEdition, wx.NewId(), _(u"&Cabeçalho/rodapé..."), _(u"Inserir/alterar cabeçalho/rodapé"), wx.ITEM_NORMAL)
        self.MenuDocEdition.AppendItem(self.MenuDocEdHeadFoot)
        self.MenuEdInsertPageNum = wx.MenuItem(self.MenuDocEdition, wx.NewId(), _(u"&Inserir número de página..."), _(u"Inserir número de página no cab./rodapé"), wx.ITEM_NORMAL)
        self.MenuDocEdition.AppendItem(self.MenuEdInsertPageNum)
        self.MenuDocEdInsertText = wx.MenuItem(self.MenuDocEdition, wx.NewId(), _("Inserir &texto...\tCTRL+ALT+I"), _(u"Inserir texto na posicão atual do documento"), wx.ITEM_NORMAL)
        self.MenuDocEdition.AppendItem(self.MenuDocEdInsertText)
        self.MenuDocEdition.AppendSeparator()
        self.MenuEditionBreak = wx.Menu()
        self.MenuDocEdInsertBreak = wx.MenuItem(self.MenuEditionBreak, wx.NewId(), _(u"De página/linha/coluna...\tCTRL+ALT+\\"), _(u"Inserir uma quebra de linha, coluna ou página"), wx.ITEM_NORMAL)
        self.MenuEditionBreak.AppendItem(self.MenuDocEdInsertBreak)
        self.MenuDocEdRemoveBreak = wx.MenuItem(self.MenuEditionBreak, wx.NewId(), _("&Remover"), _(u"Remover quebra de linha, coluna ou página da palavra sendo editada"), wx.ITEM_NORMAL)
        self.MenuEditionBreak.AppendItem(self.MenuDocEdRemoveBreak)
        self.MenuEditionBreak.AppendSeparator()
        self.MenuDocEdBreakSentence = wx.MenuItem(self.MenuEditionBreak, wx.NewId(), _(u"Fim de &sentença\tCTRL+ALT+."), _(u"Quebrar sentença após a palavra"), wx.ITEM_NORMAL)
        self.MenuEditionBreak.AppendItem(self.MenuDocEdBreakSentence)
        self.MenuDocEdBreakParag = wx.MenuItem(self.MenuEditionBreak, wx.NewId(), _(u"Fim de pará&grafo\tCTRL+ALT+P"), _(u"Quebrar parágrafo após palavra"), wx.ITEM_NORMAL)
        self.MenuEditionBreak.AppendItem(self.MenuDocEdBreakParag)
        self.MenuDocEdition.AppendMenu(wx.NewId(), _("Inserir &quebra"), self.MenuEditionBreak, "")
        self.MenuEditionToken = wx.Menu()
        self.MenuDocEdWordMoveForward = wx.MenuItem(self.MenuEditionToken, wx.NewId(), _("&Mover para frente"), _(u"Mover a palavra para depois da próxima"), wx.ITEM_NORMAL)
        self.MenuEditionToken.AppendItem(self.MenuDocEdWordMoveForward)
        self.MenuDocEdWordMoveBack = wx.MenuItem(self.MenuEditionToken, wx.NewId(), _(u"Mover para &trás"), _("Mover a palavra para antes da anterior"), wx.ITEM_NORMAL)
        self.MenuEditionToken.AppendItem(self.MenuDocEdWordMoveBack)
        self.MenuDocEdRemoveWord = wx.MenuItem(self.MenuEditionToken, wx.NewId(), _("&Remover do texto"), _("Exclui palavra sendo editada do documento"), wx.ITEM_NORMAL)
        self.MenuEditionToken.AppendItem(self.MenuDocEdRemoveWord)
        self.MenuDocEdPageNumber = wx.MenuItem(self.MenuEditionToken, wx.NewId(), _(u"Tornar &n° de página\tCTRL+ALT+N"), _(u"Transforma a palavra sendo editada em um elemento de número de página"), wx.ITEM_NORMAL)
        self.MenuEditionToken.AppendItem(self.MenuDocEdPageNumber)
        self.MenuEditionToken.AppendSeparator()
        self.MenuEdWordApply = wx.MenuItem(self.MenuEditionToken, wx.NewId(), _(u"&Aplicar edição\tCTRL+ALT+A"), _(u"Aplicar modificações sobre a palavra selecionada"), wx.ITEM_NORMAL)
        self.MenuEditionToken.AppendItem(self.MenuEdWordApply)
        self.MenuEdWordComment = wx.MenuItem(self.MenuEditionToken, wx.NewId(), _(u"&Comentários\tCTRL+ALT+C"), _(u"Comentários de edição"), wx.ITEM_NORMAL)
        self.MenuEditionToken.AppendItem(self.MenuEdWordComment)
        self.MenuDocEdition.AppendMenu(wx.NewId(), _(u"&Símbolo"), self.MenuEditionToken, "")
        self.frame_main_menubar.Append(self.MenuDocEdition, _(u"E&dição"))
        wxglade_tmp_menu = wx.Menu()
        self.MenuHelpManual = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("&Manual...\tF1"), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuHelpManual)
        wxglade_tmp_menu.AppendSeparator()
        self.MenuHelpAbout = wx.MenuItem(wxglade_tmp_menu, wx.NewId(), _("&Sobre..."), "", wx.ITEM_NORMAL)
        wxglade_tmp_menu.AppendItem(self.MenuHelpAbout)
        self.frame_main_menubar.Append(wxglade_tmp_menu, _("A&juda"))
        self.SetMenuBar(self.frame_main_menubar)
        # Menu Bar end
        self.frame_main_statusbar = self.CreateStatusBar(1, wx.ST_SIZEGRIP)
        
        # Tool Bar
        self.frame_main_toolbar = wx.ToolBar(self, -1)
        self.SetToolBar(self.frame_main_toolbar)
        self.frame_main_toolbar.AddLabelTool(ID_IMAGE_OPEN, _("Abrir imagem"), (wx.Bitmap(__builtin__.application_path + "/res/image.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Abrir imagem"), _(u"Abrir arquivo de imagem para transcrição"))
        self.frame_main_toolbar.AddSeparator()
        self.frame_main_toolbar.AddLabelTool(ID_FILE_OPEN, _("Abrir"), (wx.Bitmap(__builtin__.application_path + "/res/document-open.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Abrir"), _("Abrir um documento."))
        self.frame_main_toolbar.AddLabelTool(ID_FILE_SAVE, _("Salvar"), (wx.Bitmap(__builtin__.application_path + "/res/document-save.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Salvar"), _("Salvar o documento atual."))
        self.frame_main_toolbar.AddLabelTool(ID_FILE_SAVE_AS, _("Salvar Como"), (wx.Bitmap(__builtin__.application_path + "/res/document-save-as.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Salvar como..."), _("Salvar o documento atual usando outro nome."))
        self.frame_main_toolbar.AddSeparator()
        self.frame_main_toolbar.AddLabelTool(ID_ED_UNDO, _("Desfazer"), (wx.Bitmap(__builtin__.application_path + "/res/edit-undo.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"Desfazer última edição"))
        self.frame_main_toolbar.AddLabelTool(ID_ED_REDO, _("Refazer"), (wx.Bitmap(__builtin__.application_path + "/res/edit-redo.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, "", _(u"Refazer última operação."))
        self.frame_main_toolbar.AddSeparator()
        self.frame_main_toolbar.AddLabelTool(ID_ED_MODE, _(u"Modo de Edição"), (wx.Bitmap(__builtin__.application_path + "/res/ed-mode-on.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_CHECK, _(u"Modo de Edição"), "")
        self.frame_main_toolbar.AddLabelTool(ID_ED_PAGE_NUMBER, _(u"Número de Página"), (wx.Bitmap(__builtin__.application_path + "/res/page-number.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _(u"Inserir número de página."), "")
        self.frame_main_toolbar.AddLabelTool(ID_ED_INSERT_BREAK, _("Inserir quebra"), (wx.Bitmap(__builtin__.application_path + "/res/insert-bk.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _(u"Inserir quebra de linha, coluna ou página"), "")
        self.frame_main_toolbar.AddLabelTool(ID_ED_REMOVE_BK, _("Remover quebra"), (wx.Bitmap(__builtin__.application_path + "/res/remove-bk.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Remover quebra da palavra atual"), "")
        self.frame_main_toolbar.AddLabelTool(ID_ED_REMOVE_WORD, _("Remover palavra"), (wx.Bitmap(__builtin__.application_path + "/res/remove-word.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Excluir a palavra atual do documento"), "")
        self.frame_main_toolbar.AddLabelTool(ID_ED_INSERT_TEXT, _("Inserir texto"), (wx.Bitmap(__builtin__.application_path + "/res/insert-text.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _(u"Inserir texto na posição atual"), "")
        self.frame_main_toolbar.AddLabelTool(ID_ED_MOVE_BACK, _(u"Mover para trás"), (wx.Bitmap(__builtin__.application_path + "/res/move-back.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _(u"Mover palavra para trás"), "")
        self.frame_main_toolbar.AddLabelTool(ID_ED_MOVE_FW, _("Mover para frente"), (wx.Bitmap(__builtin__.application_path + "/res/move-fw.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Mover palavra para frente"), "")
        self.frame_main_toolbar.AddSeparator()
        self.frame_main_toolbar.AddLabelTool(ID_PROGRAM_QUIT, _("Sair"), (wx.Bitmap(__builtin__.application_path + "/res/finish.png", wx.BITMAP_TYPE_ANY)), wx.NullBitmap, wx.ITEM_NORMAL, _("Sair"), _("Sair do programa."))
        # Tool Bar end
        self.btn_repr_comm = wx.BitmapButton(self.notebook_1_pane_1, -1, wx.Bitmap(__builtin__.application_path + "/res/comment-icon.png",wx.BITMAP_TYPE_ANY))
        self.btn_repr_pg_bk = wx.BitmapButton(self.notebook_1_pane_1, -1, wx.Bitmap(__builtin__.application_path + "/res/page-break.png",wx.BITMAP_TYPE_ANY))
        self.btn_repr_ln_bk = wx.BitmapButton(self.notebook_1_pane_1, -1, wx.Bitmap(__builtin__.application_path + "/res/line1-32x32.png",wx.BITMAP_TYPE_ANY))
        self.btn_repr_col_bk = wx.BitmapButton(self.notebook_1_pane_1, -1, wx.Bitmap(__builtin__.application_path + "/res/col.png",wx.BITMAP_TYPE_ANY))
        self.text_ctrl_ocr = wx.TextCtrl(self.window_1_pane_1, -1, "", style=wx.TE_MULTILINE|wx.TE_RICH|wx.TE_RICH2|wx.TE_LINEWRAP)
        self.bmp_facsimile = wx.html.HtmlWindow(self.window_1_pane_2, -1)
        self.label_36 = wx.StaticText(self.window_1_pane_2, -1, _("Nenhuma imagem especificada."))
        self.bitmap_button_1 = wx.BitmapButton(self.window_1_pane_2, -1, wx.Bitmap(__builtin__.application_path + "/res/zoom-in.png",wx.BITMAP_TYPE_ANY))
        self.bitmap_button_2 = wx.BitmapButton(self.window_1_pane_2, -1, wx.Bitmap(__builtin__.application_path + "/res/zoom-out.png",wx.BITMAP_TYPE_ANY))
        self.label_1 = wx.StaticText(self.notebook_1_pane_grafia, -1, _("Tipo:"))
        self.comboWordType = wx.ComboBox(self.notebook_1_pane_grafia, -1, choices=[], style=wx.CB_DROPDOWN|wx.CB_DROPDOWN|wx.CB_SORT)
        self.label_2 = wx.StaticText(self.notebook_1_pane_grafia, -1, _(u"Língua:"))
        self.textWordLang = wx.TextCtrl(self.notebook_1_pane_grafia, -1, "", style=wx.TE_PROCESS_TAB)
        self.btn_bold = wx.ToggleButton(self.notebook_1_pane_grafia, -1, _("N"))
        self.btn_italic = wx.ToggleButton(self.notebook_1_pane_grafia, -1, _("I"))
        self.btn_underline = wx.ToggleButton(self.notebook_1_pane_grafia, -1, _("S"))
        self.btnApplyChanges = wx.Button(self.notebook_1_pane_grafia, -1, _(u"Aplicar alterações"))
        self.checkReplaceAll = wx.CheckBox(self.notebook_1_pane_grafia, -1, _("Substituir similares"))
        self.label_7 = wx.StaticText(self.notebook_1_pane_grafia, -1, _("Original:"))
        self.textOriginalWord = wx.TextCtrl(self.notebook_1_pane_grafia, -1, "")
        self.checkFonOriginal = wx.CheckBox(self.notebook_1_pane_grafia, -1, _(u"Análise fonológica"))
        self.checkbox_4 = wx.CheckBox(self.notebook_1_pane_grafia, -1, _("Capitular"))
        self.label_8 = wx.StaticText(self.notebook_1_pane_grafia, -1, _(u"Edição:"))
        self.textEditionType = TextCtrlAutoComplete(self.notebook_1_pane_grafia, -1, "")
        self.textEditedWord = wx.TextCtrl(self.notebook_1_pane_grafia, -1, "")
        self.btnAddEdition = wx.Button(self.notebook_1_pane_grafia, -1, _(">>"))
        self.label_9 = wx.StaticText(self.notebook_1_pane_grafia, -1, _(u"Forma fonológica:"))
        self.textFonWord = wx.TextCtrl(self.notebook_1_pane_grafia, -1, "")
        self.listEditions = wx.ListBox(self.notebook_1_pane_grafia, -1, choices=[], style=wx.LB_SINGLE)
        self.btnDeleteEdition = wx.Button(self.notebook_1_pane_grafia, -1, _("Remover"))
        self.btnDeleteAll = wx.Button(self.notebook_1_pane_grafia, -1, _("Remover tudo"))
        self.graphy_text_html_window = wx.html.HtmlWindow(self.notebook_1_pane_grafia, -1, style=wx.SIMPLE_BORDER)
        self.label_3 = wx.StaticText(self.notebook_1_pane_3, -1, _("Item:"))
        self.text_morpho_word = wx.TextCtrl(self.notebook_1_pane_3, -1, "", style=wx.TE_READONLY)
        self.label_5 = wx.StaticText(self.notebook_1_pane_3, -1, _(u"Correção:"))
        self.text_morpho_pos_fix = TextCtrlAutoComplete(self.notebook_1_pane_3, -1, "")
        self.button_apply_morpho = wx.Button(self.notebook_1_pane_3, -1, _("Aplicar"))
        self.checkbox_5 = wx.CheckBox(self.notebook_1_pane_3, -1, _("Substituir similares"))
        self.morpho_text_html_window = wx.html.HtmlWindow(self.notebook_1_pane_3, -1, style=wx.SIMPLE_BORDER)
        self.label_38 = wx.StaticText(self.panel_2, -1, _(u"Nível de edição a exibir:"))
        self.cbo_show_nivel_ed = wx.ComboBox(self.panel_2, -1, choices=[], style=wx.CB_DROPDOWN)
        self.bitmap_button_page_go_first = wx.BitmapButton(self.panel_2, -1, wx.Bitmap(__builtin__.application_path + "/res/go-first.png",wx.BITMAP_TYPE_ANY), style=wx.NO_BORDER)
        self.bitmap_button_page_go_previous = wx.BitmapButton(self.panel_2, -1, wx.Bitmap(__builtin__.application_path + "/res/go-previous.png",wx.BITMAP_TYPE_ANY), style=wx.NO_BORDER)
        self.text_ctrl_page_number = wx.TextCtrl(self.panel_2, -1, _("1"), style=wx.TE_PROCESS_ENTER|wx.TE_CENTRE)
        self.label_page_total = wx.StaticText(self.panel_2, -1, _("de 1"))
        self.bitmap_button_page_go_next = wx.BitmapButton(self.panel_2, -1, wx.Bitmap(__builtin__.application_path + "/res/go-next.png",wx.BITMAP_TYPE_ANY), style=wx.NO_BORDER)
        self.bitmap_button_page_go_last = wx.BitmapButton(self.panel_2, -1, wx.Bitmap(__builtin__.application_path + "/res/go-last.png",wx.BITMAP_TYPE_ANY), style=wx.NO_BORDER)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnMenuProgramPref, self.MenuProgramPref)
        self.Bind(wx.EVT_MENU, self.OnMenuProgramTests, self.MenuProgramTests)
        self.Bind(wx.EVT_MENU, self.OnMenuFileNew, self.MenuFileNew)
        self.Bind(wx.EVT_MENU, self.OnImageOpen, self.MenuFileImageOpen)
        self.Bind(wx.EVT_MENU, self.OnMenuFileRevert, self.MenuFileRevert)
        self.Bind(wx.EVT_MENU, self.OnMenuFileImportXML, self.MenuFileImportXML)
        self.Bind(wx.EVT_MENU, self.OnImportWordTagFormat, self.MenuFileImportWordTag)
        self.Bind(wx.EVT_MENU, self.OnExportTextFormat, self.MenuFileExportText)
        self.Bind(wx.EVT_MENU, self.OnMenuFileExportLex, self.MenuFileExportLex)
        self.Bind(wx.EVT_MENU, self.OnMenuFileExportTags, self.MenuFileExportTags)
        self.Bind(wx.EVT_MENU, self.OnMenuFileClose, self.MenuFileClose)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdUndo, self.MenuDocEdUndo)
        self.Bind(wx.EVT_MENU, self.OnMenuEditRedo, self.MenuEditRedo)
        self.Bind(wx.EVT_MENU, self.OnMenuEditCut, self.MenuEditCut)
        self.Bind(wx.EVT_MENU, self.OnMenuEditCopy, self.MenuEditCopy)
        self.Bind(wx.EVT_MENU, self.OnMenuEditPaste, self.MenuEditPaste)
        self.Bind(wx.EVT_MENU, self.OnMenuEditSelectAll, self.MenuEditSelectAll)
        self.Bind(wx.EVT_MENU, self.OnMenuEditFind, self.MenuEditFind)
        self.Bind(wx.EVT_MENU, self.OnMenuEditFindNext, self.MenuEditFindNext)
        self.Bind(wx.EVT_MENU, self.OnMenuEditFindPrevious, self.MenuEditFindPrevious)
        self.Bind(wx.EVT_MENU, self.OnMenuShowToolbar, self.MenuShowToolbar)
        self.Bind(wx.EVT_MENU, self.OnMenuShowNextTab, self.MenuShowNextTab)
        self.Bind(wx.EVT_MENU, self.OnMenuShowPreviousTab, self.MenuShowPreviousTab)
        self.Bind(wx.EVT_MENU, self.OnMenuShowRaiseFont, self.MenuShowRaiseFont)
        self.Bind(wx.EVT_MENU, self.OnMenuShowLowFont, self.MenuShowLowFont)
        self.Bind(wx.EVT_MENU, self.OnMenuShowZoomIn, self.MenuShowZoomIn)
        self.Bind(wx.EVT_MENU, self.OnMenuShowZoomOut, self.MenuShowZoomOut)
        self.Bind(wx.EVT_MENU, self.OnText2XML, self.MenuDocTxt2XML)
        self.Bind(wx.EVT_MENU, self.OnMenuDocTagging, self.MenuDocTagging)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdMeta, self.MenuDocEdMeta)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdPrevWord, self.MenuDocEdPrevWord)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdNextWord, self.MenuDocEdNextWord)
        self.Bind(wx.EVT_MENU, self.OnButtonPageGoToPrevious, self.MenuDocEdPrevPage)
        self.Bind(wx.EVT_MENU, self.OnButtonPageGoToNext, self.MenuDocEdNextPage)
        self.Bind(wx.EVT_MENU, self.OnButtonPageGoToFirst, self.MenuDocEdFirstPage)
        self.Bind(wx.EVT_MENU, self.OnButtonPageGoToLast, self.MenuDocEdLastPage)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdTextProperties, self.MenuDocEdTextProperties)
        self.Bind(wx.EVT_MENU, self.OnMenuDocComment, self.MenuDocComment)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdTextRemove, self.MenuDocEdTextRemove)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdHeadFoot, self.MenuDocEdHeadFoot)
        self.Bind(wx.EVT_MENU, self.OnMenuEdInsertPageNum, self.MenuEdInsertPageNum)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdInsertText, self.MenuDocEdInsertText)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdInsertBreak, self.MenuDocEdInsertBreak)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdRemoveBreak, self.MenuDocEdRemoveBreak)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdBreakSentence, self.MenuDocEdBreakSentence)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdBreakParag, self.MenuDocEdBreakParag)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdWordMoveForward, self.MenuDocEdWordMoveForward)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdWordMoveBack, self.MenuDocEdWordMoveBack)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdRemoveWord, self.MenuDocEdRemoveWord)
        self.Bind(wx.EVT_MENU, self.OnMenuDocEdPageNumber, self.MenuDocEdPageNumber)
        self.Bind(wx.EVT_MENU, self.OnMenuEdWordApply, self.MenuEdWordApply)
        self.Bind(wx.EVT_MENU, self.OnMenuEdWordComment, self.MenuEdWordComment)
        self.Bind(wx.EVT_MENU, self.OnMenuHelpManual, self.MenuHelpManual)
        self.Bind(wx.EVT_MENU, self.OnMenuHelpAbout, self.MenuHelpAbout)
        self.Bind(wx.EVT_TOOL, self.OnImageOpen, id=ID_IMAGE_OPEN)
        self.Bind(wx.EVT_TOOL, self.OnFileOpen, id=ID_FILE_OPEN)
        self.Bind(wx.EVT_TOOL, self.OnFileSave, id=ID_FILE_SAVE)
        self.Bind(wx.EVT_TOOL, self.OnFileSaveAs, id=ID_FILE_SAVE_AS)
        self.Bind(wx.EVT_TOOL, self.OnMenuDocEdUndo, id=ID_ED_UNDO)
        self.Bind(wx.EVT_TOOL, self.OnMenuEditRedo, id=ID_ED_REDO)
        self.Bind(wx.EVT_TOOL, self.OnEditionMode, id=ID_ED_MODE)
        self.Bind(wx.EVT_TOOL, self.OnMenuEdInsertPageNum, id=ID_ED_PAGE_NUMBER)
        self.Bind(wx.EVT_TOOL, self.OnMenuDocEdInsertBreak, id=ID_ED_INSERT_BREAK)
        self.Bind(wx.EVT_TOOL, self.OnMenuDocEdRemoveBreak, id=ID_ED_REMOVE_BK)
        self.Bind(wx.EVT_TOOL, self.OnMenuDocEdRemoveWord, id=ID_ED_REMOVE_WORD)
        self.Bind(wx.EVT_TOOL, self.OnMenuDocEdInsertText, id=ID_ED_INSERT_TEXT)
        self.Bind(wx.EVT_TOOL, self.OnMenuDocEdWordMoveBack, id=ID_ED_MOVE_BACK)
        self.Bind(wx.EVT_TOOL, self.OnMenuDocEdWordMoveForward, id=ID_ED_MOVE_FW)
        self.Bind(wx.EVT_TOOL, self.OnProgramQuit, id=ID_PROGRAM_QUIT)
        self.Bind(wx.EVT_BUTTON, self.OnReprInsComment, self.btn_repr_comm)
        self.Bind(wx.EVT_BUTTON, self.OnReprInsPageBreak, self.btn_repr_pg_bk)
        self.Bind(wx.EVT_BUTTON, self.OnReprInsLineBreak, self.btn_repr_ln_bk)
        self.Bind(wx.EVT_BUTTON, self.OnReprInsColBreak, self.btn_repr_col_bk)
        self.Bind(wx.EVT_TEXT, self.OnReproTextChange, self.text_ctrl_ocr)
        self.Bind(wx.EVT_BUTTON, self.OnMenuShowZoomIn, self.bitmap_button_1)
        self.Bind(wx.EVT_BUTTON, self.OnMenuShowZoomOut, self.bitmap_button_2)
        self.Bind(wx.EVT_BUTTON, self.OnBtnApplyChangesClicked, self.btnApplyChanges)
        self.Bind(wx.EVT_CHECKBOX, self.OnCheckFonOriginalClicked, self.checkFonOriginal)
        self.Bind(wx.EVT_BUTTON, self.OnBtnAddEditionClicked, self.btnAddEdition)
        self.Bind(wx.EVT_LISTBOX, self.OnListEditionsClicked, self.listEditions)
        self.Bind(wx.EVT_BUTTON, self.OnBtnDeleteEditionClicked, self.btnDeleteEdition)
        self.Bind(wx.EVT_BUTTON, self.OnBtnDeleteAllClicked, self.btnDeleteAll)
        self.Bind(wx.EVT_BUTTON, self.OnApplyMorphoClick, self.button_apply_morpho)
        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.OnNotebookPageChanged, self.notebook_1)
        self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGING, self.OnNotebookPageChanging, self.notebook_1)
        self.Bind(wx.EVT_COMBOBOX, self.OnCboShowNivelEdClick, self.cbo_show_nivel_ed)
        self.Bind(wx.EVT_BUTTON, self.OnButtonPageGoToFirst, self.bitmap_button_page_go_first)
        self.Bind(wx.EVT_BUTTON, self.OnButtonPageGoToPrevious, self.bitmap_button_page_go_previous)
        self.Bind(wx.EVT_TEXT_ENTER, self.OnTextEnterPageNumber, self.text_ctrl_page_number)
        self.Bind(wx.EVT_BUTTON, self.OnButtonPageGoToNext, self.bitmap_button_page_go_next)
        self.Bind(wx.EVT_BUTTON, self.OnButtonPageGoToLast, self.bitmap_button_page_go_last)
        # end wxGlade

        # initializations outside wxGlade (i.e., custom)
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.textEditedWord.Bind(wx.EVT_SET_FOCUS, self.OnTextEditedWordFocus)
        self.textEditionType.Bind(wx.EVT_SET_FOCUS, self.OnTextEditionTypeFocus)
        self.textOriginalWord.Bind(wx.EVT_TEXT, self.OnTextOriginalChange)
        self.Bind(wx.html.EVT_HTML_CELL_CLICKED, self.OnGraphyCellClicked, self.graphy_text_html_window)
        self.Bind(wx.html.EVT_HTML_CELL_CLICKED, self.OnMorphoCellClicked, self.morpho_text_html_window)

#        self.Bind(wx.EVT_KEY_DOWN, self.OnEditionTabKeyDown)

        self.text_morpho_pos_fix.SetChoices(['TAG'])
        self.textEditionType.SetChoices([_(u'Junção'),_(u'Ressegmentação')])

        # Preferences
        self.LoadPreferences()

        # Search for the temporary copy (autosave), in case of crash
        # [ppff, 10/Jul/09] INACTIVE until further development (a window to list the temp files and let the user
        #                   preview each one, before selecting some).
#        if os.path.exists(self.auto_save_file):
#            if self.YesNoMessageDialog(_(u'Foi encontrado um arquivo temporário relativo à última sessão de edição. Deseja abrí-lo?'),
#                                       _(u'E-Dictor')):
#                tmp_file = open(self.auto_save_file, 'r')
#                line = tmp_file.readline()
#                tmp_file.close()
#                if line.find('<?xml') >= 0:
#                    self.openXMLFile(self.auto_save_file, False)
#                    self.notebook_1.ChangeSelection(1)
#                    self.graphy_file_path = None
#                    self.graphy.modified = True
#                else:
#                    self.openTxtFile(self.auto_save_file, False)
#                    self.notebook_1.ChangeSelection(0)
#                    self.repro_file_path = None
            
        self.setAppTitle()
        self.text_ctrl_ocr.SetFocus()
        
        self.window_1.SetMinimumPaneSize(200)
        wx.CallLater(100, self.window_1.SetSashPosition, int(self.GetSizeTuple()[0] * 0.6))


    def __set_properties(self):
        # begin wxGlade: MainFrame.__set_properties
        self.SetTitle(_("E-Dictor"))
        self.SetSize((1080, 677))
        self.SetFocus()
        self.frame_main_statusbar.SetStatusWidths([-1])
        # statusbar fields
        frame_main_statusbar_fields = [""]
        for i in range(len(frame_main_statusbar_fields)):
            self.frame_main_statusbar.SetStatusText(frame_main_statusbar_fields[i], i)
        self.frame_main_toolbar.SetToolBitmapSize((32, 32))
        self.frame_main_toolbar.SetMargins((10, 10))
        self.frame_main_toolbar.Realize()
        self.btn_repr_comm.SetToolTipString(_(u"Insere comentário"))
        self.btn_repr_comm.SetSize(self.btn_repr_comm.GetBestSize())
        self.btn_repr_pg_bk.SetToolTipString(_(u"Insere quebra de página"))
        self.btn_repr_pg_bk.SetSize(self.btn_repr_pg_bk.GetBestSize())
        self.btn_repr_ln_bk.SetSize(self.btn_repr_ln_bk.GetBestSize())
        self.btn_repr_col_bk.SetSize(self.btn_repr_col_bk.GetBestSize())
        self.bitmap_button_1.SetSize(self.bitmap_button_1.GetBestSize())
        self.bitmap_button_2.SetSize(self.bitmap_button_2.GetBestSize())
        self.comboWordType.SetMinSize((150, 27))
        self.btn_bold.SetMinSize((24, 24))
        self.btn_bold.SetToolTipString(_("Negrito"))
        self.btn_italic.SetMinSize((24, 24))
        self.btn_italic.SetToolTipString(_(u"Itálico"))
        self.btn_underline.SetMinSize((24, 24))
        self.btn_underline.SetToolTipString(_("Sublinhado"))
        self.label_7.SetMinSize((120, 14))
        self.textOriginalWord.SetMinSize((120, 24))
        self.label_8.SetMinSize((120, 14))
        self.textEditionType.SetMinSize((150, 24))
        self.textEditedWord.SetMinSize((100, 24))
        self.btnAddEdition.SetMinSize((45, 30))
        self.label_9.SetMinSize((120, 14))
        self.textFonWord.SetMinSize((120, 24))
        self.graphy_text_html_window.SetBackgroundColour(wx.Colour(192, 192, 192))
        self.graphy_text_html_window.SetScrollRate(10, 10)
        self.notebook_1_pane_grafia.SetMinSize((1074, 520))
        self.text_morpho_word.SetMinSize((300, 50))
        self.text_morpho_word.SetBackgroundColour(wx.Colour(216, 216, 191))
        self.text_morpho_word.SetForegroundColour(wx.Colour(0, 0, 0))
        self.text_morpho_word.SetFont(wx.Font(18, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, ""))
        self.text_morpho_pos_fix.SetMinSize((120, 24))
        self.morpho_text_html_window.SetBackgroundColour(wx.Colour(192, 192, 192))
        self.morpho_text_html_window.SetScrollRate(10, 10)
        self.notebook_1.SetMinSize((999, 401))
        self.bitmap_button_page_go_first.SetToolTipString(_("Primeira"))
        self.bitmap_button_page_go_first.SetSize(self.bitmap_button_page_go_first.GetBestSize())
        self.bitmap_button_page_go_previous.SetToolTipString(_("Anterior"))
        self.bitmap_button_page_go_previous.SetSize(self.bitmap_button_page_go_previous.GetBestSize())
        self.text_ctrl_page_number.SetMinSize((40, 20))
        self.label_page_total.SetMinSize((40, 20))
        self.bitmap_button_page_go_next.SetToolTipString(_(u"Próxima"))
        self.bitmap_button_page_go_next.SetSize(self.bitmap_button_page_go_next.GetBestSize())
        self.bitmap_button_page_go_last.SetToolTipString(_(u"Última"))
        self.bitmap_button_page_go_last.SetSize(self.bitmap_button_page_go_last.GetBestSize())
        # end wxGlade
        
        self.GetToolBar().EnableTool(ID_ED_UNDO, False)
        self.GetToolBar().EnableTool(ID_ED_REDO, False)
        self.GetToolBar().EnableTool(ID_ED_MODE, False)
        self.GetToolBar().EnableTool(ID_ED_PAGE_NUMBER, False)
        for tool_id in self.toolbar_ed:
            self.GetToolBar().EnableTool(tool_id, False)

        # Initialize menu options
        self.MenuShowToolbar.Check(True)
        for menu_it in self.MenuDocEdition.GetMenuItems():
            menu_it.Enable(False)
        for menu_it in self.MenuDoc.GetMenuItems():
            menu_it.Enable(False)
        self.MenuDocTxt2XML.Enable(True)
        for menu_it in self.MenuEditionToken.GetMenuItems():
            menu_it.Enable(False)
        for menu_it in self.MenuEditionBreak.GetMenuItems():
            menu_it.Enable(False)
            
        # Exclude menu option for general tests
        self.MenuProgram.RemoveItem(self.MenuProgram.GetMenuItems()[1]) # Separator
        self.MenuProgram.RemoveItem(self.MenuProgramTests) # 'General tests' option

        # Desabilita (por enquanto) opções que parecem pouco úteis
        self.MenuDoc.RemoveItem(self.MenuDoc.GetMenuItems()[4]) # Text selection
        self.MenuDocEdition_sub.RemoveItem(self.MenuDocEdition_sub.GetMenuItems()[2]) # Separator
        self.MenuDocEdition_sub.RemoveItem(self.MenuDocEdTextRemove) # Remove text
        self.MenuEditionToken.RemoveItem(self.MenuDocEdWordMoveForward) # Move forward
        self.MenuEditionToken.RemoveItem(self.MenuDocEdWordMoveBack) # Move back
        self.MenuEditionToken.RemoveItem(self.MenuDocEdPageNumber) # Turn into page number
        self.GetToolBar().DeleteTool(ID_ED_MOVE_FW)
        self.GetToolBar().DeleteTool(ID_ED_MOVE_BACK)

        # 'Recent files' submenu
        self.updateRecentFilesMenu()

    def __do_layout(self):
        # begin wxGlade: MainFrame.__do_layout
        sizer_1 = wx.BoxSizer(wx.VERTICAL)
        sizer_6 = wx.StaticBoxSizer(self.sizer_6_staticbox, wx.HORIZONTAL)
        sizer_86 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_15 = wx.BoxSizer(wx.VERTICAL)
        sizer_26 = wx.StaticBoxSizer(self.sizer_26_staticbox, wx.HORIZONTAL)
        sizer_16 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_17 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_18_copy_copy = wx.BoxSizer(wx.HORIZONTAL)
        sizer_18 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_9 = wx.BoxSizer(wx.VERTICAL)
        sizer_grafia_texto = wx.StaticBoxSizer(self.sizer_grafia_texto_staticbox, wx.HORIZONTAL)
        sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_13 = wx.StaticBoxSizer(self.sizer_13_staticbox, wx.VERTICAL)
        sizer_19 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_20 = wx.BoxSizer(wx.VERTICAL)
        sizer_84 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_31 = wx.StaticBoxSizer(self.sizer_31_staticbox, wx.VERTICAL)
        sizer_27 = wx.BoxSizer(wx.VERTICAL)
        sizer_30 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_29 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_28 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_45 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_7 = wx.BoxSizer(wx.VERTICAL)
        sizer_35 = wx.StaticBoxSizer(self.sizer_35_staticbox, wx.VERTICAL)
        grid_sizer_1 = wx.FlexGridSizer(3, 2, 2, 2)
        sizer_37 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_36 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_32 = wx.BoxSizer(wx.VERTICAL)
        sizer_34 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_80 = wx.StaticBoxSizer(self.sizer_80_staticbox, wx.VERTICAL)
        sizer_82 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_81 = wx.StaticBoxSizer(self.sizer_81_staticbox, wx.HORIZONTAL)
        sizer_83 = wx.StaticBoxSizer(self.sizer_83_staticbox, wx.VERTICAL)
        sizer_83.Add(self.btn_repr_comm, 0, 0, 0)
        sizer_83.Add(self.btn_repr_pg_bk, 0, 0, 0)
        sizer_83.Add(self.btn_repr_ln_bk, 0, 0, 0)
        sizer_83.Add(self.btn_repr_col_bk, 0, 0, 0)
        sizer_34.Add(sizer_83, 0, wx.EXPAND, 0)
        sizer_81.Add(self.text_ctrl_ocr, 1, wx.EXPAND, 0)
        self.window_1_pane_1.SetSizer(sizer_81)
        sizer_80.Add(self.bmp_facsimile, 1, wx.EXPAND, 0)
        sizer_82.Add(self.label_36, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_82.Add(self.bitmap_button_1, 0, 0, 0)
        sizer_82.Add(self.bitmap_button_2, 0, 0, 0)
        sizer_80.Add(sizer_82, 0, wx.EXPAND, 0)
        self.window_1_pane_2.SetSizer(sizer_80)
        self.window_1.SplitVertically(self.window_1_pane_1, self.window_1_pane_2)
        sizer_34.Add(self.window_1, 1, wx.EXPAND, 0)
        sizer_32.Add(sizer_34, 1, wx.EXPAND, 0)
        self.notebook_1_pane_1.SetSizer(sizer_32)
        grid_sizer_1.Add(self.label_1, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 2)
        grid_sizer_1.Add(self.comboWordType, 0, wx.ALL, 2)
        grid_sizer_1.Add(self.label_2, 0, wx.ALL|wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_37.Add(self.textWordLang, 0, wx.ALL, 2)
        sizer_36.Add(self.btn_bold, 0, 0, 0)
        sizer_36.Add(self.btn_italic, 0, 0, 0)
        sizer_36.Add(self.btn_underline, 0, 0, 0)
        sizer_37.Add(sizer_36, 0, wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(sizer_37, 1, wx.EXPAND, 0)
        sizer_35.Add(grid_sizer_1, 1, 0, 0)
        sizer_35.Add(self.btnApplyChanges, 0, wx.ALL|wx.EXPAND, 4)
        sizer_35.Add(self.checkReplaceAll, 0, wx.LEFT, 4)
        sizer_7.Add(sizer_35, 1, wx.ALL, 2)
        sizer_5.Add(sizer_7, 0, wx.EXPAND, 0)
        sizer_28.Add(self.label_7, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_28.Add(self.textOriginalWord, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_45.Add(self.checkFonOriginal, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_45.Add(self.checkbox_4, 0, wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 10)
        sizer_28.Add(sizer_45, 1, wx.ALL|wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_27.Add(sizer_28, 1, wx.EXPAND, 0)
        sizer_29.Add(self.label_8, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_29.Add(self.textEditionType, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_29.Add(self.textEditedWord, 0, wx.LEFT|wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, 3)
        sizer_29.Add(self.btnAddEdition, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_27.Add(sizer_29, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_30.Add(self.label_9, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_30.Add(self.textFonWord, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_27.Add(sizer_30, 1, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_19.Add(sizer_27, 2, wx.EXPAND, 0)
        sizer_31.Add(self.listEditions, 1, wx.EXPAND, 0)
        sizer_20.Add(sizer_31, 1, wx.EXPAND, 0)
        sizer_84.Add(self.btnDeleteEdition, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_84.Add(self.btnDeleteAll, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_20.Add(sizer_84, 0, wx.ALIGN_CENTER_HORIZONTAL, 0)
        sizer_19.Add(sizer_20, 1, wx.EXPAND, 0)
        sizer_13.Add(sizer_19, 1, wx.EXPAND, 0)
        sizer_5.Add(sizer_13, 3, wx.ALL|wx.EXPAND, 2)
        sizer_9.Add(sizer_5, 0, wx.EXPAND, 0)
        sizer_grafia_texto.Add(self.graphy_text_html_window, 1, wx.ALL|wx.EXPAND, 2)
        sizer_9.Add(sizer_grafia_texto, 1, wx.ALL|wx.EXPAND, 5)
        self.notebook_1_pane_grafia.SetSizer(sizer_9)
        sizer_18.Add(self.label_3, 0, wx.LEFT|wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_18.Add(self.text_morpho_word, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_17.Add(sizer_18, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_18_copy_copy.Add(self.label_5, 0, wx.LEFT|wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_18_copy_copy.Add(self.text_morpho_pos_fix, 0, wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, 10)
        sizer_17.Add(sizer_18_copy_copy, 0, wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_17.Add(self.button_apply_morpho, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_17.Add(self.checkbox_5, 0, wx.LEFT|wx.ALIGN_CENTER_VERTICAL, 10)
        sizer_16.Add(sizer_17, 1, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_15.Add(sizer_16, 0, wx.ALL|wx.EXPAND|wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_26.Add(self.morpho_text_html_window, 1, wx.ALL|wx.EXPAND, 2)
        sizer_15.Add(sizer_26, 4, wx.ALL|wx.EXPAND, 5)
        self.notebook_1_pane_3.SetSizer(sizer_15)
        self.notebook_1.AddPage(self.notebook_1_pane_1, _(u"Transcrição"))
        self.notebook_1.AddPage(self.notebook_1_pane_grafia, _(u"Edição"))
        self.notebook_1.AddPage(self.notebook_1_pane_3, _("Morfologia"))
        sizer_1.Add(self.notebook_1, 1, wx.EXPAND, 0)
        sizer_86.Add(self.label_38, 0, wx.RIGHT|wx.ALIGN_CENTER_VERTICAL, 10)
        sizer_86.Add(self.cbo_show_nivel_ed, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_6.Add(sizer_86, 0, wx.EXPAND, 0)
        sizer_6.Add((20, 20), 1, wx.EXPAND, 0)
        sizer_6.Add(self.bitmap_button_page_go_first, 0, 0, 1)
        sizer_6.Add(self.bitmap_button_page_go_previous, 0, 0, 1)
        sizer_6.Add(self.text_ctrl_page_number, 0, wx.LEFT|wx.RIGHT|wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_6.Add(self.label_page_total, 0, wx.LEFT|wx.RIGHT|wx.ALIGN_CENTER_HORIZONTAL|wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_6.Add(self.bitmap_button_page_go_next, 0, 0, 2)
        sizer_6.Add(self.bitmap_button_page_go_last, 0, 0, 0)
        self.panel_2.SetSizer(sizer_6)
        sizer_1.Add(self.panel_2, 0, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        self.Layout()
        self.Centre()
        self.SetSize((1080, 677))
        # end wxGlade

        self.Maximize()

    def initVariables(self):
        '''
        Initialize variables for edition handling.
        '''
        self.menu_opts = {}
        self.orig_ocr_text = ''
        self.active_text = 0
        self.cell_ref = None
        self.cur_page = 1
        
        self.repro_file_path = None

        self.graphy_file_path = None
        self.graphy = None
        self.graphy_cell = None
        self.graphy_word_editing = None

        self.morpho_seg_ii = 0
        self.morpho_cell = None
        self.is_morpho_loaded = False
        self.morpho_word_editing = None

        self.undo_stack = []
        self.redo_stack = []
        self.fg_all = False

        self.zoom = 100
        self.image_size = None
        self.image_path = ""
        self.last_image_path = os.getcwd()        
        
    def updateRecentFilesMenu(self):
#        self.MenuFileOpenRecent.RemoveItem(self.MenuFileOpenRecent.GetMenuItems()[0])
        submenu = self.MenuFileOpenRecent
        for m in submenu.GetMenuItems():
            submenu.DeleteItem(m)

        self.rfiles_opts = {}
        for f in self.recent_files:
            if len(f) > 0:
                f = f.strip()
                rfile_opt_id = wx.NewId()
                self.rfiles_opts[rfile_opt_id] = f
                self.Bind(wx.EVT_MENU, self.OnMenuRecentFile, id=rfile_opt_id)
                submenu.Append(rfile_opt_id, f, "")
        
    def SetStatusBarMessage(self, text):
        self.frame_main_statusbar.SetStatusText(text, 0)

    ##----------------------------------
    # Helping dialog boxes

    def YesNoMessageDialog(self, question, caption = _(u"Sim ou Não?")):
        dlg = wx.MessageDialog(self, question, caption, wx.YES_NO | wx.NO_DEFAULT | wx.ICON_QUESTION)
        result = dlg.ShowModal() == wx.ID_YES
        dlg.Destroy()
        return result

    def InfoMessageDialog(self, message, caption = _(u"Informação")):
        dlg = wx.MessageDialog(self, message, caption, wx.OK | wx.ICON_INFORMATION)
        dlg.ShowModal()
        dlg.Destroy()

    def InfoTextMessageDialog(self, message, caption=_(u'Informação!')):
        dlg = dialogs.scrolledMessageDialog(self, message, caption)
        dlg.ShowModal()
   
    def WarnMessageDialog(self, message, caption = _(u"Atenção!")):
        dlg = wx.MessageDialog(self, message, caption, wx.OK | wx.ICON_WARNING)
        dlg.ShowModal()
        dlg.Destroy()
  
    def ErrorMessageDialog(self, message, caption = _(u"Erro!")):
        dlg = wx.MessageDialog(self, message, caption, wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        return result

    def MessageDialog(self, message, caption, style):
        dlg = wx.MessageDialog(self, message, caption, style)
        result = dlg.ShowModal()
        dlg.Destroy()
        return result

    def InfoHtmlMessageDialog(self, message, caption=_(u'Informação!')):
        dlg = ScrolledMessageDialog(self, message, caption)
        result = dlg.ShowModal()
        dlg.Destroy()
        return result

    ##----------------------------------
    # begin tabs functions

    def ClearGraphyView(self):
        self.textEditedWord.Clear()
        self.textOriginalWord.Clear()
        self.textWordLang.Clear()
        self.textFonWord.Clear()
        self.textFonWord.Enable(True)
        self.comboWordType.SetSelection(0)
        self.textEditionType.Clear()
        self.checkFonOriginal.SetValue(False)
        self.listEditions.Clear()
        
    def LoadGraphy(self, graphy, page_number=0):
        try:
            html_header = '<html><body><font size="' + str(self.font_size_GRA) + '" color=black>'
            html_footer = '</font></body></html>'
#            print 'content load',
#            t = time.time()
            eds = self.ed_types[0:self.ed_labels.index(self.cbo_show_nivel_ed.GetStringSelection())+1]
            eds.reverse()
            html_body = self.graphy.getTexts()[self.active_text].getHtmlVersion(page_number, eds)
#            t = time.time() - t
#            print t
            return html_header + html_body + html_footer
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Erro ao carregar conteúdo (Edição)!'), u'E-Dictor')
        return ""
    
    def processTextBreaks(self, word):
        '''
        Process text breaks such as paragraphs and sections. Line and
        column breaks are treated directly by the Word.getHtmlString()
        method. DEPRECATED on 05/Jan/09 by ppff
        '''
        str = ''
        # Check if the word informed is the last in its paragraph
        for p in word.node.iterancestors(tag='p'):
            w_list = p.findall('s')
            w_list = w_list[len(w_list) - 1].findall('w')
            if len(w_list) > 0 and w_list[len(w_list) - 1].get('id') == word.node.get('id'):
                str += '<br><br>'
            break
        return str
        
    def WriteGraphy(self, html):
        self.graphy_text_html_window.SetPage(html)
        
    def LoadGraphyWord(self, graphy, word, ref):
        word.setFocused(True)
        self.textEditedWord.Clear()
        wordObj = graphy.getTexts()[self.active_text].getWordByRef(ref)
        i = 0
        if wordObj.getType() != '':
            i = self.comboWordType.FindString(wordObj.getType())
        self.comboWordType.SetSelection(i)
        self.textEditionType.Clear()
        self.textWordLang.ChangeValue(wordObj.getLanguage())
        self.textOriginalWord.ChangeValue(wordObj.getOriginalString('|'))
        self.textFonWord.ChangeValue(wordObj.getPhonologicalString())
        self.checkFonOriginal.SetValue(wordObj.isOriginalAsFon())
        self.checkReplaceAll.SetValue(False)
        self.checkReplaceAll.Enable(True)
        self.textFonWord.Enable(not wordObj.isOriginalAsFon())
        self.graphy_word_editing = wordObj
        self.listEditions.Clear()
        # Format
        self.checkbox_4.SetValue(wordObj.isCapitular())        
        self.btn_bold.SetValue(wordObj.isBold())
        self.btn_italic.SetValue(wordObj.isItalic())
        self.btn_underline.SetValue(wordObj.isUnderlined())
        if wordObj.isEdited():
            #self.checkReplaceAll.Enable('jun' not in wordObj.map['edition'])
            for ed in self.ed_types:
                if ed in wordObj.map['edition']:
                    ed_label = self.ed_labels[self.ed_types.index(ed)]
                    self.listEditions.Insert(wordObj.getEditedString(ed) + \
                                             ' | ' + ed_label, 0)                
        self.remove_list = []                

    def OnTextOriginalChange(self, event):
#        if self.graphy_word_editing is not None:
#            self.checkReplaceAll.Enable(self.graphy_word_editing.getOriginalString('|') == self.textOriginalWord.GetValue())
#            if self.graphy_word_editing.getOriginalString('|') != self.textOriginalWord.GetValue():
#                self.checkReplaceAll.SetValue(False)
        event.Skip()
        
    def ChangeGraphyWord(self, w):
        if w is not None:
            # Verify if the user really wants to proceed
            for ed in self.listEditions.GetItems():
                ed_type = ed.split(' | ')[1]
                if ed_type == _(u"Junção"):
                    if w.getOriginalString('|') != self.textOriginalWord.GetValue():
                        wx.MessageBox(_(u"Forma original não pode ser alterada quando há junção na lista de edições."), _(u"E-Dictor"))
                        self.textOriginalWord.ChangeValue(w.getOriginalString('|'))
                        self.textOriginalWord.SetFocus()
                        return False
                    if not ed.split(' | ')[0] == ''.join(self.textOriginalWord.GetValue().split()) and\
                            not self.test_mode and not self.fg_all and\
                            not self.YesNoMessageDialog(_(u"Lembre-se que as edições da palavra seguinte serão perdidas após a junção. Continua?"), _(u"E-Dictor")):
                        return False

#            if w.getOriginalString('|').find('|') >= 0 and self.textOriginalWord.GetValue().find('|') < 0:
#                wx.MessageBox(_(u"A marca de quebra de linha ('|') não pode ser retirada manualmente, modificando a forma original. Utilize a opção 'Inserir quebra -> Remover', no menu de edições."), _(u"E-Dictor"))
#            if w.getOriginalString('|').find('|') < 0 and self.textOriginalWord.GetValue().find('|') >= 0:
#                wx.MessageBox(_(u"A marca de quebra de linha ('|') não pode ser incluída manualmente, modificando a forma original. Utilize a opção 'Inserir quebra -> De página/linha/coluna', no menu de edições."), _(u"E-Dictor"))

            # Procede
            self.SetStatusBarMessage(_(u'Aplicando edições à palavra...'))
            # Formats
            formats = []
            if self.btn_bold.GetValue(): formats.append('b')
            if self.btn_italic.GetValue(): formats.append('i')
            if self.btn_underline.GetValue(): formats.append('u')

            self.log(u'Log: [op:ChangeGraphyWord] [params: id:' + self.graphy_word_editing.getId() +\
                                       ', or:' + w.getOriginalString('|') +\
                                       ', type:' + self.comboWordType.GetStringSelection() +\
                                       ', lang:' + self.textWordLang.GetValue() +\
                                       ', or-new:' + self.textOriginalWord.GetValue() +\
                                       ', chk-fon:' + unicode(self.checkFonOriginal.GetValue()) +\
                                       ', fon:' + self.textFonWord.GetValue() +\
                                       ', f:' + str(formats) +\
                                       ', r-list:' + ' ; '.join(self.remove_list) +\
                                       ', e-list:' + ' ; '.join(self.listEditions.GetItems()) + ']\n')

            # Update the properties of the Word object
            w.setType(self.comboWordType.GetStringSelection())
            w.setLanguage(self.textWordLang.GetValue())
            # Update the original content and fonological information
            if w.getOriginalString('') != self.textOriginalWord.GetValue().replace('|',''): # Compare the 'bare' original form
                if w.getOriginalString('|').find('|') >= 0 and self.textOriginalWord.GetValue().find('|') < 0:
                    pos = w.getOriginalString('|').find('|')
                    self.textOriginalWord.SetValue(self.textOriginalWord.GetValue()[0:pos-1] + '|' + self.textOriginalWord.GetValue()[pos:])
                if w.getOriginalString('|').find('|') < 0 and self.textOriginalWord.GetValue().find('|') >= 0:
                    self.textOriginalWord.SetValue(self.textOriginalWord.GetValue().replace('|',''))
                self.graphy.getTexts()[self.active_text].removeDuplicate(w.getOriginalString(),w.getId())
                self.graphy.getTexts()[self.active_text].insertDuplicate(self.textOriginalWord.GetValue().replace('|',''),w.getId())
            w.setOriginalString(self.textOriginalWord.GetValue())
            w.setOriginalAsFon(self.checkFonOriginal.GetValue())
            if self.textFonWord.Enabled:
                w.setPhonologicalString(self.textFonWord.GetValue())
            else:
                w.setPhonologicalString('')
            w.setFormat(formats)
            w.setCapitular(self.checkbox_4.GetValue())
            # Update editions
            if len(self.remove_list) > 0:
                w.clearEditions(self.remove_list, self.graphy.getTexts()[self.active_text], self.undo_stack, self.active_text, self.GetCurrentPageNumber())
            if 'jun' in self.remove_list:
                self.listEditions.Clear() # Discard all remaining editions
            for ed in self.listEditions.GetItems():
                ed_type = ed.split(' | ')[1]
                t = self.ed_types[self.ed_labels.index(ed_type)]
                if t == 'jun' and ed.split(' | ')[0] != ''.join(w.getOriginalString().split()):
                    self.graphy.getTexts()[self.active_text].removeDuplicate(w.getOriginalString(),w.getId())
                    self.graphy.getTexts()[self.active_text].insertDuplicate(ed.split(' | ')[0].replace(w.getOriginalString(),\
                                                                                                        w.getOriginalString() + ' '),w.getId())
                rt, msg = w.setEdition(ed.split(' | ')[0], t, self.graphy.getTexts()[self.active_text], self.undo_stack, self.active_text, self.GetCurrentPageNumber())
                if not rt:
                    # If an edition fails to apply do not continue
                    wx.MessageBox(_(u"Problemas na aplicação das edições: ") + msg, _(u"E-Dictor"))
                    break
            self.SetStatusBarMessage(u'')
            return True
        return False

    def ClearMorphoView(self):
        self.text_morpho_word.Clear()
        #self.text_morpho_pos_tag.Clear()
        self.text_morpho_pos_fix.Clear()

    def WriteMorpho(self, html):
        self.morpho_text_html_window.SetPage(html)
        self.morpho_text_html_window.Refresh()
        self.is_morpho_loaded = True

    def LoadMorpho(self, page_number=0):
        if self.graphy is None:
            return ""
        try:
            html_header = u'<html><body><font size=' + str(self.font_size_GRA) + ' color=black>'
            html_footer = '</font></body></html>'
            eds = self.ed_types[0:self.ed_labels.index(self.cbo_show_nivel_ed.GetStringSelection())+1]
            eds.reverse()
            html_body = self.graphy.getTexts()[self.active_text].getHtmlPOSVersion(page_number, eds)
            return html_header + html_body + html_footer
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Erro ao carregar conteúdo (Morfologia)!'), u'E-Dictor')
        return ""
        
    def LoadMorphoWord(self, word, ref):
        self.text_morpho_pos_fix.Clear()
        wordObj = self.graphy.getTexts()[self.active_text].getWordByRef(ref)
        if wordObj.hasPartOfSpeech():
            self.text_morpho_word.ChangeValue(wordObj.getString().split('_')[self.morpho_seg_ii]+'/'+\
                                              wordObj.getPartOfSpeech()[self.morpho_seg_ii])
            #self.text_morpho_pos_tag.ChangeValue(wordObj.getPartOfSpeech()[self.morpho_seg_ii])
        else:
            self.text_morpho_word.ChangeValue(wordObj.getString().split('_')[self.morpho_seg_ii])
        self.morpho_word_editing = wordObj
        self.checkbox_5.SetValue(False)

    def ChangeMorphoWord(self, w_obj):
        if w_obj is not None:
            tag = self.text_morpho_pos_fix.GetValue().upper()
            if tag != '':
                if tag not in __builtin__.cfg.get(u'Preferences', u'POS_tag_list').split('|'):
                    if not eval(__builtin__.cfg.get(u'Preferences', u'New_POS_tag_on_demand')):
                        wx.MessageBox(_(u'Esta etiqueta precisa ser cadastrada na lista (na janela de Preferências).'), _(u'E-Dictor'))
                        self.text_morpho_pos_fix.SetFocus()
                        return False
                    else:
                        if not self.YesNoMessageDialog(_(u'Esta é uma nova etiqueta. Confirma?'), _(u'E-Dictor')):
                            self.text_morpho_pos_fix.SetFocus()
                            return False
                        else:
                            # Save new tag in preferences file and update text componente tag list
                            tmp_list = __builtin__.cfg.get(u'Preferences', u'POS_tag_list').split('|')
                            tmp_list.append(tag)
                            __builtin__.cfg.set(u'Preferences', u'POS_tag_list', '|'.join(tmp_list))
                            self.text_morpho_pos_fix.SetChoices(tmp_list)
                            
                w = w_obj
                self.log(u'Log: [op:ChangeMorphoWord] [params: id:' + w.getId() +\
                         ', or:' + w.getPartOfSpeech()[self.morpho_seg_ii] +\
                         ', new:' + tag + ']\n')
                w_obj.setPartOfSpeech(tag, self.morpho_seg_ii)
                #self.text_morpho_pos_tag.ChangeValue(tag)
                return True
        return False 

    # end tabs functions

    #----------------------------------
    # begin auxiliary functions

    def DoExit(self):
        # Save preferences and properties
        self.closeFile()
        self.SavePreferences()
        return True

    # end auxiliary functions
    #----------------------------------

    #----------------------------------
    # begin menu and toolbar callers 

    def OnProgramQuit(self, event): # wxGlade: MainFrame.<event_handler>
        if ((self.txt_modified and
                    not self.text_ctrl_ocr.GetValue().strip() == '')
                or (self.graphy is not None and self.graphy.isModified())) and\
                not self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja mesmo sair?"), _(u"E-Dictor")):
            return False
        # Save preferences and properties
        self.closeFile()
        self.SavePreferences()
        sys.exit()

    def OnClose(self, event):
        if ((self.txt_modified and
                    not self.text_ctrl_ocr.GetValue().strip() == '')
                    or (self.graphy is not None and self.graphy.isModified())) and\
                not self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja mesmo sair?"), _(u"E-Dictor")):
            return False
        # Save preferences and properties
        self.closeFile()
        self.SavePreferences()
        sys.exit()

    def SavePreferences(self):
        '''
        Save E-Dictor preferences to a file.
        '''
        cfg_file = codecs.open(self.properties_file.encode('utf-8'),'w','utf-8')
        if len(self.recent_files) > 10: self.recent_files = self.recent_files[0:10]
        __builtin__.cfg.set(u'File Settings',u'Recent files', ",".join(name.encode('utf-8') for name in self.recent_files))
        __builtin__.cfg.set(u'Preferences',u'Font_size_GRA', str(self.font_size_GRA))
        __builtin__.cfg.set(u'Preferences',u'Font_size_REP', str(self.font_size_REP))
        __builtin__.cfg.write(cfg_file)

    def LoadPreferences(self):
        '''
        Load preferences from configuration file.
        '''
        PreferencesDialog(self).configDialog(self)
        
        # App general settings
        self.backup_copy = True
        self.auto_save = True
        if os.name in ['posix','mac']:
            self.auto_save_file = os.getenv('HOME') + '/.e-dictor/e-dictor_'+str(SESSION_ID)+'.tmp'
        else:
            self.auto_save_file = os.getenv('APPDATA') + '\e-dictor\e-dictor_'+str(SESSION_ID)+'.tmp'

        if __builtin__.cfg.has_option(u'Preferences', u'Backup_copy'):
            self.backup_copy = eval(__builtin__.cfg.get(u'Preferences', u'Backup_copy'))
        if __builtin__.cfg.has_option(u'Preferences', u'Auto_save'):
            self.auto_save = eval(__builtin__.cfg.get(u'Preferences', u'Auto_save'))
        
        # Word possible editions types (ordered from first to last)
        self.ed_types = []
        self.ed_labels = []
        if __builtin__.cfg.get(u'Preferences', u'EditionTypes') != '':
            self.cbo_show_nivel_ed.Clear()
            for ed in __builtin__.cfg.get(u'Preferences', u'EditionTypes').decode('utf-8').split(','):
                type, label = ed.split('|')
                self.ed_types.append(type)
                self.ed_labels.append(label)
                self.cbo_show_nivel_ed.Append(label)
            self.textEditionType.SetChoices(self.ed_labels)
            # Exibe (por padrão) o nível máximo de edição
            self.cbo_show_nivel_ed.Select(self.cbo_show_nivel_ed.GetCount() - 1)

        # Word possible editions types (ordered from first to last)
        if __builtin__.cfg.get(u'Preferences', u'POS_tag_list') != '':
            morpho_tags = __builtin__.cfg.get(u'Preferences', u'POS_tag_list').split('|')
            morpho_tags.sort()
            self.text_morpho_pos_fix.SetChoices(morpho_tags)

        # Word 'special types'
        self.comboWordType.Clear()
        self.comboWordType.Append('')
        if __builtin__.cfg.get(u'Preferences', u'ElementTypes') != '':
            for p in __builtin__.cfg.get(u'Preferences', u'ElementTypes').decode('utf-8').split(','):
                while p.count('|') <= 2:
                    p += '|'
                el, desc, pos, css = p.split('|')
                if el == _(u'Palavra'):
                    self.comboWordType.Append(desc)
        
    def OnImageOpen(self, event): # wxGlade: MainFrame.<event_handler>
        wildcard = _(u"Todos arquivos (*.*)|*.*")
        wildcard = _(u"Arquivos de figuras (gif,jpg,png,bmp)|*.gif;*.GIF;*.jpg;*.JPG;*.jpeg;*.JPEG;*.png;*.PNG;*.bmp;*.BMP|") + wildcard
        dlg = wx.FileDialog(
            self, message=_(u"Abrir figura"), defaultDir=self.last_image_path,
            defaultFile="", wildcard=wildcard, style=wx.OPEN | wx.CHANGE_DIR
            )
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            try:
                image = wx.Image(path, wx.BITMAP_TYPE_ANY).ConvertToBitmap()
                self.image_path = path
                if self.bmp_facsimile.GetClientSizeTuple()[0] > image.GetWidth():
                    self.image_size = (image.GetWidth(), image.GetHeight())
                else:
                    self.image_size = (self.bmp_facsimile.GetClientSizeTuple()[0], 
                                       int(image.GetHeight() * self.bmp_facsimile.GetClientSizeTuple()[0]/image.GetWidth())) 
                self.bmp_facsimile.SetPage('<img src="'+path+'" width="%d" height="%d" border=0/>' % 
                                           self.image_size)
                self.label_36.SetLabel(path)
                self.last_image_path = os.path.dirname(path)
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                self.ErrorMessageDialog(msg, _(u"Erro abrindo figura!"))
                self.SetStatusBarMessage(_(u"Erro abrindo figura!"))
        dlg.Destroy()

    def OnFileOpen(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy is not None and self.graphy.isModified() and\
                not self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja prosseguir?"), _(u"E-Dictor")):
            return
        
        self.closeFile()
        self.setAppTitle()
        self.SetStatusBarMessage('')

        current_tab = self.notebook_1.GetCurrentPage().GetId()
        wildcard = _(u"Todos arquivos (*.*)|*.*")
        
        if current_tab == ID_TAB_REP:
            wildcard = _(u"Arquivos de texto (*.txt)|*.txt;*.TXT|") + wildcard
            dlg = wx.FileDialog(
                self, message=_(u"Abrir arquivo"), defaultDir=os.getcwd(),
                defaultFile="", wildcard=wildcard, style=wx.OPEN | wx.CHANGE_DIR
                )
            if dlg.ShowModal() == wx.ID_OK:
                self.openTxtFile(dlg.GetPath())
            dlg.Destroy()
        elif current_tab in [ID_TAB_GRA, ID_TAB_MOR]:
            wildcard = _(u"Arquivos XML (*.xml)|*.xml;*.XML|") + wildcard
            dlg = wx.FileDialog(
                self, message=_(u"Abrir arquivo"), defaultDir=os.getcwd(),
                defaultFile="", wildcard=wildcard, style=wx.OPEN | wx.CHANGE_DIR
                )
            if dlg.ShowModal() == wx.ID_OK:
                self.openXMLFile(dlg.GetPath())
            dlg.Destroy()
        elif current_tab == ID_TAB_SIN:
            pass
        else:
            pass

    def openTxtFile(self, path, menu=True):
        try:
            self.log(u'Log: [op:openTxtFile] [params:' + path + ']\n')
            if self.text_ctrl_ocr.LoadFile(path):
                self.undo_stack = []
                self.redo_stack = []
                self.notebook_1_pane_1.Enable(True)
                if self.GetToolBar():
                    self.GetToolBar().EnableTool(ID_ED_UNDO, False)
                    self.GetToolBar().EnableTool(ID_ED_REDO, False)
                self.orig_ocr_text = self.text_ctrl_ocr.GetValue()
                self.repro_file_path = path
                
                # Update recent files menu
                if menu:
                    if path in self.recent_files:
                        # obs.: self.recent_files.remove(path) didn't work...
                        self.recent_files.pop(self.recent_files.index(path))
                    self.recent_files.insert(0, path)
                    self.updateRecentFilesMenu()

                self.SetStatusBarMessage(_(u"Arquivo %s aberto.")%path)
            else:
                raise
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            self.ErrorMessageDialog(msg, _(u"Erro abrindo arquivo!"))
            self.SetStatusBarMessage(_(u"Erro abrindo arquivo!"))
        
    def openXMLFile(self, path, menu=True):
        try:
            self.SetStatusBarMessage(_(u"Abrindo arquivo %s...")%path)
            graphy = Graphy()
            self.log(u'Log: [op:openXMLFile] [params:' + path + ']\n')
            if graphy.OpenXMLFile(path):
                self.undo_stack = []
                self.redo_stack = []
                self.graphy = graphy
                self.active_text = 0
                self.LoadPage(1)
                self.turnOffEdition()
                self.graphy_file_path = path
                
                # Update recent files menu
                if menu:
                    if path in self.recent_files:
                        # obs.: self.recent_files.remove(path) didn't work...
                        self.recent_files.pop(self.recent_files.index(path))
                    self.recent_files.insert(0, path)
                    self.updateRecentFilesMenu()
                
                self.createDocumentTextsMenus()
                if self.GetToolBar():
                    self.GetToolBar().EnableTool(ID_ED_MODE, True)
                    self.GetToolBar().EnableTool(ID_ED_PAGE_NUMBER, True)
                self.notebook_1_pane_1.Enable(False)
                for menu_it in self.MenuDocEdition.GetMenuItems():
                    menu_it.Enable(True)
                for menu_it in self.MenuDoc.GetMenuItems():
                    menu_it.Enable(True)
                self.MenuDocTxt2XML.Enable(False)
                self.SetStatusBarMessage(_(u"Arquivo %s aberto.")%path)
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            self.ErrorMessageDialog(msg, _(u"Erro abrindo arquivo!"))
            self.SetStatusBarMessage(_(u"Erro abrindo arquivo!"))
        
    def createDocumentTextsMenus(self):
        '''
        Creates menu options to enable access to each of the
        document texts.
        '''
# Desabilitado por Pablo em 30/09/2011: estou pensando em tirar essa opção
#        submenu = self.MenuDocSelText
#        for m in submenu.GetMenuItems():
#            if len(submenu.GetMenuItems()) == 1: break
#            submenu.DeleteItem(m)
#        
#        self.menu_opts = {}
#        ii = 0
#        for text_obj in self.graphy.getTexts():
#            menu_opt_id = wx.NewId()
#            self.menu_opts[menu_opt_id] = ii
#            self.Bind(wx.EVT_MENU, self.OnSelectTextMenu, id=menu_opt_id)
#            try:
#                submenu.AppendRadioItem(menu_opt_id, text_obj.getTitle() + u' (' + text_obj.getAuthor() + u')', "")
#            except:
#                # This avoids a warning message in Windows
#                pass
#            ii += 1
#        # Exclui item inicial do menu
#        submenu.DeleteItem(submenu.GetMenuItems()[0])
#        # Select the first option
#        for m in self.MenuDocSelText.GetMenuItems():
#            if self.menu_opts[m.GetId()] == self.active_text:
#                m.Check(True)
#                break
        self.setAppTitle()

    def OnSelectTextMenu(self, event):
        '''
        Change selected text and show its first page.
        '''
        self.turnOffEdition()
        self.active_text = self.menu_opts[event.GetId()]
        if self.GetCurrentPageNumber() == 1:
            self.ReloadCurrentPage()
        else:
            self.GoToPageNumber(1)
        self.setAppTitle()
        
    def OnMenuRecentFile(self, event):
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_REP:
            if self.orig_ocr_text != self.text_ctrl_ocr.GetValue() and\
                    not self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja prosseguir?"), _(u"E-Dictor")):
                return
        else:
            if self.graphy is not None and self.graphy.isModified() and\
                    not self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja prosseguir?"), _(u"E-Dictor")):
                return

        self.closeFile()
        
        path = self.rfiles_opts[event.GetId()]
        if path.endswith(".txt"): 
            self.notebook_1.ChangeSelection(0)
            self.openTxtFile(path)
        else:
            self.notebook_1.ChangeSelection(1)
            self.openXMLFile(path)
        self.setAppTitle()
        
        # Update recent files menu
        if path in self.recent_files:
            # obs.: self.recent_files.remove(path) didn't work...
            self.recent_files.pop(self.recent_files.index(path))
        self.recent_files.insert(0, path)
        self.updateRecentFilesMenu()

    def setAppTitle(self): 
        path = _(u'*novo*')
        if self.graphy_file_path is not None:
            path = u'' + self.graphy_file_path
        if self.repro_file_path is not None:
            path = u'' + self.repro_file_path
        tt = u''
        if self.graphy is not None and self.graphy.getTexts()[self.active_text].getTitle():
            tt = u' :: ' + self.graphy.getTexts()[self.active_text].getTitle()
        self.SetTitle(_(u'E-Dictor') + ' [' + path + tt + u']')

    def OnFileSave(self, event): # wxGlade: MainFrame.<event_handler>
        current_tab = self.notebook_1.GetCurrentPage().GetId()
        path = None
        if current_tab == ID_TAB_REP:
            if self.text_ctrl_ocr.IsEmpty():
                self.SetStatusBarMessage(_(u"Nada a ser salvo."))
                return
            if self.repro_file_path is None:
                self.OnFileSaveAs(event)
            else:
                self.log(u'Log: [op:OnFileSave] [params:TXT, ' + self.repro_file_path + ']\n')
                if self.backup_copy:
                    if os.name in ['posix','mac']:
                        # Unix-based
                        shutil.copy(self.repro_file_path, self.repro_file_path+'~')
                    else:
                        # Windows
                        shutil.copy(self.repro_file_path, os.path.dirname(self.repro_file_path) + '~' + os.path.basename(self.repro_file_path) +'.TMP')
                    
                if self.text_ctrl_ocr.SaveFile(self.repro_file_path):
                    self.txt_modified = False
                    self.orig_ocr_text = self.text_ctrl_ocr.GetValue()
                    path = self.repro_file_path
                    self.SetStatusBarMessage(_(u"Arquivo salvo em '%s'.")%self.repro_file_path)
                else:
                    msg = _(u"Não foi possível salvar o arquivo. Não sei o por quê. :)")
                    self.ErrorMessageDialog(msg, _(u"Erro salvando arquivo!"))
                    self.SetStatusBarMessage(_(u"Erro salvando arquivo!"))
        elif current_tab == ID_TAB_GRA or current_tab == ID_TAB_MOR:
            if not self.graphy:
                self.SetStatusBarMessage(_(u"Nada a ser salvo."))
                return
            if self.graphy_file_path is None:
                self.OnFileSaveAs(event)
            else:
                try:
                    self.log(u'Log: [op:OnFileSave] [params:XML, ' + self.graphy_file_path + ']\n')
                    if self.backup_copy:
                        if os.name in ['posix','mac']:
                            # Unix-based
                            shutil.copy(self.graphy_file_path, self.graphy_file_path+'~')
                        else:
                            # Windows
                            shutil.copy(self.graphy_file_path, os.path.dirname(self.graphy_file_path) + '\~' + os.path.basename(self.graphy_file_path) + '.TMP')
                    prefix = os.path.basename(self.graphy_file_path)
                    prefix = os.path.splitext(prefix)[0]
                    self.graphy.setPrefix(prefix)
                    self.graphy.SaveXMLFile(self.graphy_file_path)
                    path = self.graphy_file_path
                    self.SetStatusBarMessage(_(u"Arquivo salvo em '%s'.")%self.graphy_file_path)
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                    self.ErrorMessageDialog(msg, _(u"Erro salvando arquivo!"))
                    self.SetStatusBarMessage(_(u"Erro salvando arquivo!"))
        else:
            pass

        # Update recent files menu
        if path is not None:
            if path in self.recent_files:
                # obs.: self.recent_files.remove(path) didn't work...
                self.recent_files.pop(self.recent_files.index(path))
            self.recent_files.insert(0, path)
            self.updateRecentFilesMenu()

    def OnFileSaveAs(self, event): # wxGlade: MainFrame.<event_handler>
        current_tab = self.notebook_1.GetCurrentPage().GetId()
        wildcard = _(u"Todos arquivos (*.*)|*.*")
        if current_tab == ID_TAB_REP:
            if self.text_ctrl_ocr.IsEmpty():
                self.SetStatusBarMessage(_(u"Nada a ser salvo."))
                return
            dlg = wx.SingleChoiceDialog(
                    self, _(u"Salvar em qual formato?"), _(u"Salvar Arquivo"),
                    [_(u"Texto puro"), _(u"Criar XML")], 
                    wx.CHOICEDLG_STYLE
                    )
            if dlg.ShowModal() == wx.ID_OK:
                sel = dlg.GetSelection()
                dlg.Destroy()
                if sel == 0: # Save as text
                    wildcard = _(u"Arquivos de texto (*.txt)|*.txt;*.TXT|") + wildcard
                    ext = '.txt'
                elif sel == 1: # Save as XML
                    wildcard = _(u"Arquivos XML (*.xml)|*.xml;*.XML|") + wildcard
                    ext = '.xml'
                if self.repro_file_path is None:
                    dir = os.getcwd()
                    file_name = '*' + ext
                else:
                    dir = os.path.dirname(self.repro_file_path)
                    file_name = os.path.basename(self.repro_file_path)
                    root = os.path.splitext(file_name)[0]
                    if root:
                        file_name = root + ext
                dlg = wx.FileDialog(
                    self, message=_(u"Salvar arquivo"), defaultDir=dir,
                    defaultFile=file_name, wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT
                    )
                if dlg.ShowModal() == wx.ID_OK:
                    try:
                        path = dlg.GetPath()
                        if sel == 0: # Save as text
                            self.log(u'Log: [op:OnFileSaveAs] [params:TXT, ' + path + ']\n')
                            if self.text_ctrl_ocr.SaveFile(path):
                                self.repro_file_path = path
                                ret = True
                                # Update recent files menu
                                if path in self.recent_files:
                                    # obs.: self.recent_files.remove(path) didn't work...
                                    self.recent_files.pop(self.recent_files.index(path))
                                self.recent_files.insert(0, path)
                                self.updateRecentFilesMenu()
                                self.setAppTitle()
                                self.txt_modified = False
                                self.SetStatusBarMessage(_(u"Arquivo salvo em '%s'.")%self.repro_file_path)
                            else:
                                msg = _(u"Não foi possível salvar o arquivo. Não sei o por quê. :)")
                                self.ErrorMessageDialog(msg, _(u"Erro salvando arquivo!"))
                                self.SetStatusBarMessage(_(u"Erro salvando arquivo!"))
                                ret = False
                        elif sel == 1: # Save as XML, but continues to show the simple text TAB
                            self.log(u'Log: [op:OnFileSaveAs] [params:XML, ' + path + ']\n')
                            prefix = os.path.basename(path)
                            prefix = os.path.splitext(prefix)[0]
                            tree = Graphy()
                            text = self.text_ctrl_ocr.GetValue()
                            tree.createFromText(text, prefix)
                            tree.SaveXMLFile(path)
                            self.graphy_file_path = path
                            ret = True
                    except:
                        msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                        self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                        traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                        self.ErrorMessageDialog(msg, _(u"Erro salvando arquivo!"))
                        self.SetStatusBarMessage(_(u"Erro salvando arquivo!"))
                        ret = False
                dlg.Destroy()
                return ret
        elif current_tab == ID_TAB_GRA or current_tab == ID_TAB_MOR:
            wildcard = _(u"Arquivos XML (*.xml)|*.xml;*.XML|") + wildcard
            if not self.graphy:
                self.SetStatusBarMessage(_(u"Nada a ser salvo."))
                return
            if self.graphy_file_path is None:
                dir = os.getcwd()
                file_name = '*.xml'
            else:
                dir = os.path.dirname(self.graphy_file_path)
                file_name = os.path.basename(self.graphy_file_path)
            dlg = wx.FileDialog(
                self, message=_(u"Salvar arquivo"), defaultDir=dir,
                defaultFile=file_name, wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT
                )
            if dlg.ShowModal() == wx.ID_OK:
                try:
                    path = dlg.GetPath()
                    self.log(u'Log: [op:OnFileSaveAs] [params:XML, ' + path + ']\n')
                    prefix = os.path.basename(path)
                    prefix = os.path.splitext(prefix)[0]
                    self.graphy.setPrefix(prefix)
                    self.graphy.SaveXMLFile(path)
                    self.graphy_file_path = path
                    # Update recent files menu
                    if path in self.recent_files:
                        # obs.: self.recent_files.remove(path) didn't work...
                        self.recent_files.pop(self.recent_files.index(path))
                    self.recent_files.insert(0, path)
                    self.updateRecentFilesMenu()
                    dlg.Destroy()
                    self.setAppTitle()
                    self.SetStatusBarMessage(_(u"Arquivo salvo em '%s'.")%path)
                    return True
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                    self.ErrorMessageDialog(msg, _(u"Erro salvando arquivo!"))
                    self.SetStatusBarMessage(_(u"Erro salvando arquivo!"))
                    dlg.Destroy()
                    return False
            else:
                dlg.Destroy()
                return False
        else:
            pass

    def OnTextChange(self, event):
        self.txt_modified = True

    def OnImportWordTagFormat(self, event): # wxGlade: MainFrame.<event_handler>
#        if True:
#            wx.MessageBox(_(u"Opção desativada, por enquanto."), _(u"E-Dictor"))
#            return
    
        if not self.graphy:
            self.WarnMessageDialog(_(u"Não é possível importar se um arquivo\nmarcado (XML) não for aberto antes."), _(u"Importação cancelada"))
            self.SetStatusBarMessage(_(u"É necessário abrir um arquivo marcado (XML) antes de importar."))
            return

        wildcard = _(u"Arquivos de texto (*.txt)|*.txt;*.TXT|") + _(u"Todos arquivos (*.*)|*.*")
        dir = os.getcwd()
        file_name = ''
        if self.graphy_file_path:
            dir = os.path.dirname(self.graphy_file_path)
            file_name = os.path.basename(self.graphy_file_path)
            root = os.path.splitext(file_name)[0]
            if root:
                file_name = root + '_pos.txt'
        dlg = wx.FileDialog(
            self, message=_(u"Importar de arquivo"), defaultDir=dir,
            defaultFile=file_name, wildcard=wildcard, style=wx.OPEN | wx.CHANGE_DIR
            )
        if dlg.ShowModal() == wx.ID_OK:
            try:
                path = dlg.GetPath()
                with codecs.open(path, 'r', encoding='utf-8') as f:
                    text = f.read()
                self.log(u'Log: [op:importFromWordTagFromat] [params:' + text + ']\n')
                wx.BeginBusyCursor()
                self.SetStatusBarMessage(_(u"Trabalhando..."))
                ret, msg = self.graphy.getTexts()[self.active_text].importFromWordTagFormat(text)
                self.graphy.modified = True
                if not ret:
                    self.SetStatusBarMessage(_(u"Erro importando de arquivo!"))
                    wx.MessageBox(msg, _(u"Erro importando de arquivo!"))
                else:
                    self.notebook_1.ChangeSelection(2)
                    self.ReloadCurrentPage()
                    wx.MessageBox(_(u'Importação efetuada com sucesso!'), _(u"E-Dictor"))
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                self.ErrorMessageDialog(msg, _(u"Erro importando de arquivo!"))
                self.SetStatusBarMessage(_(u"Erro importando de arquivo!"))
        dlg.Destroy()
        wx.EndBusyCursor()

    def OnExportTextFormat(self, event): # wxGlade: MainFrame.<event_handler>
        if not self.graphy:
            self.WarnMessageDialog(_(u"Nenhum dado para exportar."), _(u"Exportação cancelada"))
            self.SetStatusBarMessage(_(u"Nenhum dado para exportar."))
            return
        dlg = ExportTextDialog(self)
        dlg.setEditionLevels(self.ed_labels[1:])
        if dlg.ShowModal() == wx.ID_OK:
            try:
                self.log(u'Log: [op:exportText] [params:' + dlg.getEditionLevel() + ',' + str(dlg.getFileType()) + ',' + str(dlg.getOptions()) + ']\n')
                doc_name = ''
                if self.graphy_file_path:
                    doc_name = os.path.splitext(os.path.basename(self.graphy_file_path))[0]
                wx.BeginBusyCursor()
                self.SetStatusBarMessage(_(u"Gerando conteúdo a ser exportado. Aguarde..."))
                content = self.graphy.getTexts()[self.active_text].exportText(doc_name, dlg.getEditionLevel(), 
                                                                              dlg.getFileType(), dlg.getOptions())
                wx.EndBusyCursor()
                if content is not None:
                    # Save file
                    if dlg.getFileType() == 0:
                        wildcard = _(u"Arquivos de texto (*.txt)|*.txt;*.TXT|") + _(u"Todos arquivos (*.*)|*.*")
                        file_ext = '.txt'
                        file_name = '*.txt'
                    else:
                        wildcard = _(u"Arquivos HTML (*.html)|*.html;*.HTML|") + _(u"Todos arquivos (*.*)|*.*")
                        file_ext = '.html'
                        file_name = '*.html'
                    dir = os.getcwd()
                    if self.graphy_file_path:
                        dir = os.path.dirname(self.graphy_file_path)
                        file_name = os.path.basename(self.graphy_file_path)
                        root = os.path.splitext(file_name)[0]
                        if root:
                            file_name = root + file_ext
                    dlg_file = wx.FileDialog(self, message=_(u"Exportar para arquivo"), defaultDir=dir,
                                             defaultFile=file_name, wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
                    if dlg_file.ShowModal() == wx.ID_OK:
                        try:
                            path = dlg_file.GetPath()
                            self.log(u'Log: [op:exportTextFormat] [params:False]\n')
                            with codecs.open(path, 'w', encoding='utf-8') as f:
                                f.write(content)
                            self.SetStatusBarMessage(_(u"Dados exportados para '%s'.")%path)
                        except:
                            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                            self.ErrorMessageDialog(msg, _(u"Erro exportando para arquivo!"))
                            self.SetStatusBarMessage(msg)
                    dlg_file.Destroy()
                else:
                    msg = _(u"Não foi possível exportar os dados.")
                    self.ErrorMessageDialog(msg, _(u"Erro exportando para arquivo!"))
                    self.SetStatusBarMessage(msg)
            except:
                wx.EndBusyCursor()
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
                    
        dlg.Destroy()

    # end menu and toolbar callers
    ###############

    #----------------------------------
    # begin event handlers

    def OnGraphyCellClicked(self, event): # wxGlade: MainFrame.<event_handler>
        cell = event.GetCell()
        if isinstance(cell, wx.html.HtmlWordCell):
            sel = wx.html.HtmlSelection()
            word = cell.ConvertToText(sel).strip()
            if not word:
                return
            if cell.GetLink():
                self.cell_ref = cell.GetLink().GetHref().lower()
                if self.cell_ref.find('_') < 0: # word
                    if self.graphy_word_editing is not None:
                        self.graphy_word_editing.setFocused(False)
                    self.graphy_word_editing = self.graphy.getTexts()[self.active_text].getWordByRef(self.cell_ref)
                    self.LoadGraphyWord(self.graphy, self.graphy_word_editing, self.cell_ref)
                    self.turnOnEdition()
                    self.graphy_cell = cell
                    self.graphy_text_html_window.SelectWord(self.graphy_cell.GetAbsPos())
                    self.scrollToCurrentCell()
                else: # other elements (paragraph, sentence, etc.)
                    if self.cell_ref is not None:
                        self.graphy_text_html_window.Refresh()
                        self.graphy_text_html_window.SelectWord(cell.GetAbsPos())
        if self.cell_ref is not None and (event.GetMouseEvent().GetButton() == wx.MOUSE_BTN_RIGHT or\
                                          self.cell_ref.find('_') >= 0):
            self.OnGraphyCellRightClicked(event)

    def OnGraphyCellRightClicked(self, event):
        # only do this part the first time so the events are only bound once
        if self.cell_ref.find('_') < 0: # word
            menu = self.MenuDocEdition
        else: #if self.cell_ref.find('p_') >= 0 or self.cell_ref.find('s_') >= 0:
            self.turnOffEdition()
            if not hasattr(self, "popupGraphyID1"):
                self.MenuElements = wx.Menu()
                self.popupGraphyID1 = wx.NewId()
                self.popupGraphyID2 = wx.NewId()
                self.popupGraphyID3 = wx.NewId()
                self.popupGraphyID4 = wx.NewId()
                self.popupGraphyID5 = wx.NewId()
                self.popupGraphyID6 = wx.NewId()
                self.Bind(wx.EVT_MENU, self.OnPopupGraphyCellRemove, id=self.popupGraphyID1)
                self.Bind(wx.EVT_MENU, self.OnPopupGraphyCellMerge, id=self.popupGraphyID2)
                self.Bind(wx.EVT_MENU, self.OnPopupGraphyCellComment, id=self.popupGraphyID4)
                self.Bind(wx.EVT_MENU, self.OnPopupGraphyCellProperties, id=self.popupGraphyID3)
                self.Bind(wx.EVT_MENU, self.OnPopupGraphyCellSectionEnd, id=self.popupGraphyID5)
                self.Bind(wx.EVT_MENU, self.OnPopupGraphyCellTextEnd, id=self.popupGraphyID6)
                self.MenuElements.Append(wx.NewId(), '[ '+self.cell_ref+' ]')
                self.MenuElements.Append(self.popupGraphyID3, _(u"Propriedades"))
                self.MenuElements.Append(self.popupGraphyID4, _(u"Comentários"))
                self.MenuElements.AppendSeparator()
                self.MenuElements.Append(self.popupGraphyID1, _(u"Excluir do texto"))
                self.MenuElements.Append(self.popupGraphyID2, _(u"Fundir com anterior"))
                self.MenuElements.AppendSeparator()
                self.MenuElements.Append(self.popupGraphyID5, _(u"Iniciar nova seção aqui"))
                self.MenuElements.Append(self.popupGraphyID6, _(u"Iniciar novo texto aqui"))
                self.MenuElements.GetMenuItems()[0].Enable(False)
            else:
                if hasattr(self.MenuElements.GetMenuItems()[0], 'SetItemLabel'):
                    self.MenuElements.GetMenuItems()[0].SetItemLabel(u'[ '+self.cell_ref+' ]')
                else:
                    self.MenuElements.GetMenuItems()[0].SetText(u'[ '+self.cell_ref+' ]')
            self.MenuElements.GetMenuItems()[1].Enable(self.cell_ref.find('te_') < 0)
            self.MenuElements.GetMenuItems()[2].Enable(self.cell_ref.find('sce_') < 0 and\
                                                       self.cell_ref.find('te_') < 0 and\
                                                       self.cell_ref.find('s_') < 0)
            self.MenuElements.GetMenuItems()[5].Enable(self.cell_ref.find('sc_') >= 0 or self.cell_ref.find('p_') >= 0 or\
                                                       self.cell_ref.find('s_') >= 0)
            not_sce_child = (self.cell_ref.find('p_') >= 0 and\
                             self.graphy.getTexts()[self.active_text].getElementByRef(self.cell_ref).getParent().node.tag != 'sce')
            self.MenuElements.GetMenuItems()[7].Enable(not_sce_child)
            self.MenuElements.GetMenuItems()[8].Enable(not_sce_child)
            menu = self.MenuElements
        # event: MouseEvent
        self.PopupMenu(menu) #, event.GetPosition()) # out of position

    def OnPopupGraphyCellComment(self, event):
        '''
        Open dialog for comments about the element selected.
        '''
        el_obj = self.graphy.getTexts()[self.active_text].getElementByRef(self.cell_ref)
        if el_obj is not None:
            dlg = CommentsDialog(self)
            dlg.setComments(el_obj.getId(), el_obj.getComments())
            if dlg.ShowModal() == wx.ID_OK:
                try:
                    self.log(u'Log: [op:setComments] [params:' + el_obj.getId() + ']\n')
                    el_obj.setComments(dlg.getComments())
                    self.graphy.modified = True
                    self.ReloadCurrentPage()
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                    wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
    
    def OnPopupGraphyCellRemove(self, event):
        '''
        Remove the selected element from the document.
        '''
        prefix = self.cell_ref.lower()[0:self.cell_ref.lower().rfind('_')]
        if prefix == 'sc' and len(self.graphy.getTexts()[self.active_text].getElements()) == 1:
            wx.MessageBox(_(u'Não é permitido remover a única seção do texto.'), _(u'E-Dictor'))
            return

        # Procede
        self.SetStatusBarMessage(_(u'Removendo elemento...'))
        try:
            self.log(u'Log: [op:removeElementByRef] [params:' + self.cell_ref + ']\n')
            if self.YesNoMessageDialog(_(u'Confirma remoção deste elemento?'), _(u'E-Dictor')) and\
                    self.graphy.getTexts()[self.active_text].removeElementByRef(self.cell_ref, self.undo_stack, self.active_text, self.GetCurrentPageNumber()):
                self.redo_stack = []
                if self.GetCurrentPageNumber() > self.graphy.getTexts()[self.active_text].last_page:
                    self.GoToPageNumber(self.graphy.getTexts()[self.active_text].last_page)
                else: 
                    self.ReloadCurrentPage()
                self.graphy_word_editing = None
                self.turnOffEdition()
            self.SetStatusBarMessage('')
        except:
            pass

    def OnPopupGraphyCellMerge(self, event):
        '''
        Merge the selected element with the previous one (if any).
        '''
        if self.YesNoMessageDialog(_(u'Confirma fusão deste elemento com o anterior?'), _(u'E-Dictor')):
            wx.BeginBusyCursor()
            self.SetStatusBarMessage(_(u'Executando a fusão...'))
            try:
                self.log(u'Log: [op:mergeElement] [params:' + self.cell_ref + ']\n')
                rt, msg = self.graphy.getTexts()[self.active_text].mergeElement(self.cell_ref, self.undo_stack, self.active_text, self.GetCurrentPageNumber())
                if rt:
                    self.redo_stack = []
                    self.ReloadCurrentPage()
                    self.turnOffEdition()
                else:
                    wx.MessageBox(msg, _(u'E-Dictor'))
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
            wx.EndBusyCursor()
        self.SetStatusBarMessage('')

    def OnPopupGraphyCellProperties(self, event):
        '''
        Show the element properties dialog.
        '''
        dialog = ElementPropertiesDialog(None)
        if dialog.setElement(self.graphy.getTexts()[self.active_text].getElementByRef(self.cell_ref), 
                             self.undo_stack, self.active_text, self.GetCurrentPageNumber()) and\
                dialog.ShowModal() == wx.ID_OK:
            self.log(u'Log: [op:el-properties] [params:' + self.cell_ref + ']\n')
            self.redo_stack = []
            self.ReloadCurrentPage()

    def OnPopupGraphyCellSectionEnd(self, event):
        '''
        Breaks the section immediately before the selected paragraph.
        '''
        wx.BeginBusyCursor()
        try:
            self.log(u'Log: [op:breakSection] [params:' + self.cell_ref + ']\n')
            rt, msg = self.graphy.getTexts()[self.active_text].breakSection(self.cell_ref, self.undo_stack,
                                                                            self.active_text, self.GetCurrentPageNumber())
            if rt:
                self.redo_stack = []
                self.ReloadCurrentPage()
            if msg != '':
                wx.MessageBox(msg, _(u'E-Dictor'))
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
        wx.EndBusyCursor()

    def OnPopupGraphyCellTextEnd(self, event):
        '''
        Breaks the text immediately before the selected paragraph.
        '''
        wx.BeginBusyCursor()
        try:
            self.log(u'Log: [op:breakText] [params:' + self.cell_ref + ']\n')
            rt, msg = self.graphy.getTexts()[self.active_text].breakText(self.cell_ref, self.graphy, self.undo_stack, self.active_text, self.GetCurrentPageNumber())
            if rt:
                self.redo_stack = []
                self.createDocumentTextsMenus()
                for m in self.MenuDocSelText.GetMenuItems():
                    if self.menu_opts[m.GetId()] == self.active_text:
                        m.Check(True)
                        break
                self.ReloadCurrentPage()
            if msg != '':
                wx.MessageBox(msg, _(u'E-Dictor'))
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
        wx.EndBusyCursor()
        
    def OnNotebookPageChanging(self, event): # wxGlade: MainFrame.<event_handler>
        closing_tab = self.notebook_1.GetCurrentPage().GetId()
        #print "CurrentPage:", closing_tab
        if closing_tab == ID_TAB_REP:
            if self.GetToolBar():
                self.GetToolBar().EnableTool(ID_IMAGE_OPEN, False)
        elif closing_tab == ID_TAB_GRA:
            if self.GetToolBar():
                for tool_id in self.toolbar_ed:
                    self.GetToolBar().EnableTool(tool_id, False)
            for menu_it in self.MenuDocEdition.GetMenuItems():
                menu_it.Enable(False)
        elif closing_tab == ID_TAB_MOR:
            pass
        elif closing_tab == ID_TAB_SIN:
            pass
        else:
            pass

    def OnNotebookPageChanged(self, event): # wxGlade: MainFrame.<event_handler>
        current_tab = self.notebook_1.GetCurrentPage().GetId()
        if current_tab == ID_TAB_REP:
            if self.GetToolBar():
                self.GetToolBar().EnableTool(ID_ED_MODE, False)
                self.GetToolBar().EnableTool(ID_ED_PAGE_NUMBER, False)
                self.GetToolBar().EnableTool(ID_IMAGE_OPEN, True)
            self.text_ctrl_ocr.SetFocus()
        elif current_tab == ID_TAB_GRA:
            if self.morpho_word_editing is not None: self.graphy_word_editing = self.morpho_word_editing 
            if self.GetToolBar():
                self.GetToolBar().EnableTool(ID_ED_MODE, True)
                self.GetToolBar().EnableTool(ID_IMAGE_OPEN, False)
                if self.graphy is not None:
                    self.GetToolBar().EnableTool(ID_ED_PAGE_NUMBER, True)
                if self.ed_mode:
                    for tool_id in self.toolbar_ed:
                        self.GetToolBar().EnableTool(tool_id, tool_id != ID_ED_REMOVE_BK or self.graphy_word_editing.getOriginalString('|').find('|') >= 0)
                    self.turnOnEdition()
            for menu_it in self.MenuDocEdition.GetMenuItems():
                menu_it.Enable(True)
        elif current_tab == ID_TAB_MOR:
            self.ClearMorphoView()
            if self.graphy_word_editing is not None and self.graphy_word_editing.isRelevantToPOS():
                self.morpho_word_editing = self.graphy_word_editing
            else:
                self.turnOffEdition()
            if self.GetToolBar():
                self.GetToolBar().EnableTool(ID_ED_MODE, True)
                self.GetToolBar().EnableTool(ID_IMAGE_OPEN, False)
                self.GetToolBar().EnableTool(ID_ED_PAGE_NUMBER, False)
                if self.ed_mode:
                    self.turnOnEdition()
        elif current_tab == ID_TAB_SIN:
            pass
        else:
            pass

    def OnMorphoCellClicked(self, event): # wxGlade: MainFrame.<event_handler>
        cell = event.GetCell()
        if isinstance(cell, wx.html.HtmlWordCell):
            sel = wx.html.HtmlSelection()
            word = cell.ConvertToText(sel).strip()
            if not word:
                return
            if cell.GetLink():
                (self.cell_ref, self.morpho_seg_ii) = cell.GetLink().GetHref().split(':')
                self.morpho_seg_ii = int(self.morpho_seg_ii)
                if not self.graphy.getTexts()[self.active_text].getWordByRef(self.cell_ref).isRelevantToPOS():
                    self.turnOffEdition()
                    return
                if self.morpho_word_editing is not None:
                    self.morpho_word_editing.setFocused(False)
                self.morpho_word_editing = self.graphy.getTexts()[self.active_text].getWordByRef(self.cell_ref)
                self.graphy_word_editing = self.morpho_word_editing
                self.LoadMorphoWord(self.morpho_word_editing, self.cell_ref)
                self.morpho_cell = cell
                self.morpho_text_html_window.SelectWord(self.morpho_cell.GetAbsPos())
                self.turnOnEdition()

    def GetCurrentPageNumber(self):
        try:
            return int(self.text_ctrl_page_number.GetValue())
        except ValueError:
            self.SetStatusBarMessage(_(u"Número de página inválido (%s).")%(str(self.text_ctrl_page_number.GetValue())))
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            return 1

    def GoToPageNumber(self, pgn):
        if not isinstance(pgn, int):
            self.SetStatusBarMessage(_(u"Número de página inválido (%s).")%(pgn))
            return
        try:
            lpn = int(self.graphy.getTexts()[self.active_text].getLastPageNumber())
        except AttributeError:
            self.SetStatusBarMessage(_(u"Nenhum dado carregado ainda."))
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            return
        if pgn > lpn: pgn = lpn
        if pgn < 1: pgn = 1
        if pgn != self.cur_page:
            self.LoadPage(pgn)
            if self.ed_mode:
                self.turnOnEdition()

    def ReloadCurrentPage(self):
        self.LoadPage(self.GetCurrentPageNumber())

    def LoadPage(self, pgn, flag_clear=True):
        wx.BeginBusyCursor()
        try:
            self.SetStatusBarMessage(_(u'Carregando a página...'))
            self.WriteGraphy(self.LoadGraphy(self.graphy, pgn))
            self.WriteMorpho(self.LoadMorpho(pgn))
            self.text_ctrl_page_number.ChangeValue(str(pgn))
            if flag_clear: self.ClearGraphyView()
            if self.auto_save and (time.time() - self.LAST_SAVE_TIME) >= 90:
                self.SetStatusBarMessage(_(u'Salvando cópia automática...'))
                self.graphy.SaveXMLFile(self.auto_save_file, self.graphy.isModified())
                self.SetStatusBarMessage(u'')
                self.LAST_SAVE_TIME = time.time()
            self.SetStatusBarMessage('')
            self.label_page_total.SetLabel(_(u'de ') + str(self.graphy.getTexts()[self.active_text].getLastPageNumber()))
            if self.GetToolBar():
                self.GetToolBar().EnableTool(ID_ED_UNDO, len(self.undo_stack) > 0)
                self.GetToolBar().EnableTool(ID_ED_REDO, len(self.redo_stack) > 0)
                if len(self.undo_stack) > 0:
                    self.GetToolBar().SetToolLongHelp(ID_ED_UNDO, self.undo_stack[0][-1])
                else:
                    self.GetToolBar().SetToolLongHelp(ID_ED_UNDO, _(u'Nada a desfazer.'))
                if len(self.redo_stack) > 0:
                    self.GetToolBar().SetToolLongHelp(ID_ED_REDO, self.redo_stack[0][-1])
                else:
                    self.GetToolBar().SetToolLongHelp(ID_ED_REDO, _(u'Nada a refazer.'))
            self.cur_page = pgn
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Página não pode ser carregada!'), u'E-Dictor')
        wx.EndBusyCursor()

    def OnButtonPageGoToFirst(self, event): # wxGlade: MainFrame.<event_handler>
        self.GoToPageNumber(1)

    def OnButtonPageGoToPrevious(self, event): # wxGlade: MainFrame.<event_handler>
        try:
            pgn = self.GetCurrentPageNumber()
            pgn -= 1
            self.GoToPageNumber(pgn)
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))

    def OnTextEnterPageNumber(self, event): # wxGlade: MainFrame.<event_handler>
        try:
            pgn = int(self.text_ctrl_page_number.GetValue())
            self.GoToPageNumber(pgn)
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))

    def OnButtonPageGoToNext(self, event): # wxGlade: MainFrame.<event_handler>
        try:
            pgn = self.GetCurrentPageNumber()
            pgn += 1
            self.GoToPageNumber(pgn)
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))

    def OnButtonPageGoToLast(self, event): # wxGlade: MainFrame.<event_handler>
        self.GoToPageNumber(sys.maxint)

    def OnText2XML(self, event): # wxGlade: MainFrame.<event_handler>
        '''
        Generate the basic XML structure for the raw text entered and
        moves to the 'Edição' tab.
        '''
        if self.graphy and not self.test_mode and not self.YesNoMessageDialog(_(u"Há uma estrutura XML em uso. Ela precisará ser descartada para a conversão. Continua?"), _(u"E-Dictor")):
            return
        if self.text_ctrl_ocr.IsEmpty():
            self.SetStatusBarMessage(_(u"Nada a ser gerado."))
            return
        wx.BeginBusyCursor()
        try:
            self.log(u'Log: [op:onText2XML]\n')
            self.SetStatusBarMessage(_(u"Gerando estrutura XML para o texto..."))
            text = self.text_ctrl_ocr.GetValue().strip()
            graphy = Graphy()
            rt, msg = graphy.createFromText(text, "tmp")
            if not rt:
                wx.MessageBox(msg, _('E-Dictor'))
                wx.EndBusyCursor()
                return
            self.closeFile()
            self.graphy_file_path = None
            self.graphy = graphy
            self.LoadPage(1)
            self.notebook_1.ChangeSelection(1)
            self.notebook_1_pane_1.Enable(False)
            self.GetToolBar().EnableTool(ID_ED_MODE, True)
            self.GetToolBar().EnableTool(ID_IMAGE_OPEN, False)
            self.GetToolBar().EnableTool(ID_ED_PAGE_NUMBER, True)
            time.sleep(.5)
            self.setAppTitle()
            for menu_it in self.MenuDocEdition.GetMenuItems():
                menu_it.Enable(True)
            for menu_it in self.MenuDoc.GetMenuItems():
                menu_it.Enable(True)
            self.MenuDocTxt2XML.Enable(False)
            self.SetStatusBarMessage(_(u"Estrutura XML base gerada com sucesso (") +\
                                     str(len(self.graphy.getTexts()[self.active_text].getWordsList())) +\
                                     _(u" palavras processadas)."))
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
        wx.EndBusyCursor()

    def OnCheckFonOriginalClicked(self, event): # wxGlade: MainFrame.<event_handler>
        self.textFonWord.Enable(not self.checkFonOriginal.GetValue())

    def OnTextEditionTypeFocus(self, event):
        pass
    
    def OnTextEditedWordFocus(self, event): # wxGlade: MainFrame.<event_handler>
        ed_label = self.textEditionType.GetValue().strip()
        if self.graphy_word_editing is not None and ed_label in self.ed_labels:
            str = self.textOriginalWord.GetValue().replace('|','')
            # Get the closer edited form (or itself if already informed)
            if self.textEditionType.GetValue() != _(u'Junção'):
                def loop(str):
                    ed_index = self.ed_labels.index(ed_label)
                    tmp = self.ed_labels[:ed_index+1]
                    tmp.reverse()
                    for ed in tmp:
                        for edition in self.listEditions.GetStrings():
                            if re.match('.* \| '+ed, edition):
                                return edition.split(' | ')[0]
                    return str
                str = loop(str)
            if self.textEditionType.GetValue() == _(u'Junção'):
                if self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing,
                             not isinstance(self.graphy_word_editing.getParent().getParent().getParent(), SectionElement)) is not None:
                    str = str.replace(' ','')
                    next_w = self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing,
                                 not isinstance(self.graphy_word_editing.getParent().getParent().getParent(), SectionElement))
                    if next_w.isEdited('jun'):
                        str += next_w.getEditedString('jun')
                    else:
                        str += next_w.getOriginalString()
                    self.textEditedWord.ChangeValue(str)
                    self.OnBtnAddEditionClicked(event)
                    return
                else:
                    # Não faz nada, pois não há 'próxima palavra' a juntar
                    self.textEditionType.Clear()
                    self.textEditionType.SetFocus()
                    return
            self.textEditedWord.ChangeValue(str)
        else:
            self.textEditedWord.ChangeValue('')

    def OnBtnDeleteEditionClicked(self, event): # wxGlade: MainFrame.<event_handler>
        ed_type = self.listEditions.GetSelection()
        if ed_type != wx.NOT_FOUND:
            sel = self.listEditions.GetStringSelection().split(' | ')[1]
            t = self.ed_labels.index(sel)
            self.remove_list.append(self.ed_types[t])
            self.listEditions.Delete(ed_type)
            self.textEditionType.Clear()
            self.textEditedWord.Clear()
            self.textEditionType.SetFocus()

    def OnBtnApplyChangesClicked(self, event): # wxGlade: MainFrame.<event_handler>
        wx.BeginBusyCursor()
        try:
            # Undo information
            w_list = [(self.graphy_word_editing, self.graphy_word_editing.node.__deepcopy__(False),
                       self.graphy_word_editing.getParent().getElements().index(self.graphy_word_editing),
                       self.graphy_word_editing.node.getparent().index(self.graphy_word_editing.node))]
            dup_list = []
            self.undo_stack.insert(0, ['W-EDIT', w_list, [], self.active_text, self.GetCurrentPageNumber(), _(u'Desfazer edição de palavra.')])
            wedit_list = self.undo_stack[0][1]
            flag_or = True #(self.graphy_word_editing.getOriginalString('|') == self.textOriginalWord.GetValue())
            dup_list = self.graphy.getTexts()[self.active_text].getWordDuplicatesIDsList(self.graphy_word_editing)

            # In case of 'junction' with 'replace all' option: adjacent strings must be the same 
            w_str = self.graphy_word_editing.getOriginalString('')
            if self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing) is not None:
                nextw_str = self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing).getOriginalString('')
            flag_jun = False
            for ed in self.listEditions.GetItems():
                ed_type = ed.split(' | ')[1]
                if ed_type == _(u"Junção"): flag_jun = True

            # Procede

            if not self.ChangeGraphyWord(self.graphy_word_editing):
                self.undo_stack.pop(0) # Cancel undo
                wx.EndBusyCursor()
                return
            self.redo_stack = []
            # Replace all occurrences (if demanded and if THERE IS NO CHANGE in the original form)
            if self.checkReplaceAll.GetValue() and flag_or:
                self.fg_all = True
                self.SetStatusBarMessage(_(u'Atualizando as demais ocorrências de "%s"...')%self.graphy_word_editing.getString())
                dlg_rt = None
                nr_repl = 0
                for w_id in dup_list:
                    w = self.graphy.getTexts()[self.active_text].getWordByRef(w_id)
                    if flag_jun:
                        # Replace All + Junction: break marks must be removed from the original textbox
                        self.textOriginalWord.SetValue(self.textOriginalWord.GetValue().replace('|',''))
                    if (not flag_jun) or ((w_str + nextw_str) == \
                           (w.getOriginalString('') + 
                            self.graphy.getTexts()[self.active_text].getNextWord(w).getOriginalString(''))):
                        if dlg_rt != wx.ID_REPLACE_ALL:
                            if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(w):
                                self.LoadPage(self.graphy.getTexts()[self.active_text].getWordContainingPage(w), False)
                            else:
                                self.LoadPage(self.GetCurrentPageNumber(), False)
                            self.highlightCell(self.graphy_text_html_window.GetInternalRepresentation(), w.getId())
                            self.scrollToCurrentCell()
                            dlg_rt = self.ed_repl_dialog.ShowModal()
                        if dlg_rt == wx.ID_CANCEL: break
                        if dlg_rt != wx.ID_IGNORE: 
                            # Undo stack
                            wedit_list.append((w, w.node.__deepcopy__(False),
                                               w.getParent().getElements().index(w), w.node.getparent().index(w.node)))
                            # Update
                            if not self.ChangeGraphyWord(w):
                                self.undo_stack[0][1].pop(-1) # Cancel undo
                            else:
                                nr_repl += 1
            if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(self.graphy_word_editing):
                self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(self.graphy_word_editing))
            else:
                self.ReloadCurrentPage()
            # Focus the next word
            self.graphy_word_editing.setFocused(False)
            w = self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing)
            if w is not None:
                self.graphy_word_editing = w
                if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(w):
                    self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(w))
                self.turnOnEdition()
            else:
                self.turnOffEdition()
            self.graphy.modified = True
            if self.fg_all:
                self.SetStatusBarMessage(unicode(nr_repl+1) + _(u' palavras atualizadas.'))
            self.fg_all = False
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
        wx.EndBusyCursor()

    def OnBtnAddEditionClicked(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is not None \
                and not self.textEditionType.GetValue().strip() == '' \
                and not self.textEditedWord.GetValue() == '':
            # Remove previous edition of the same type (if some)
            for edition in self.listEditions.GetStrings():
                if re.match('.* \| '+self.textEditionType.GetValue(), edition):
                    self.listEditions.Delete(self.listEditions.FindString(edition))
                    break
            self.listEditions.Insert(self.textEditedWord.GetValue()+ \
                                     ' | '+self.textEditionType.GetValue(), 0)
            # Do not permit Replace All if there is 'jun'
#            if self.textEditionType.GetValue() == _(u'Junção'):
#                self.checkReplaceAll.Enable(False)
#                self.checkReplaceAll.SetValue(False)

            self.textEditedWord.Clear()
            self.textEditionType.Clear()
            self.textEditionType.SetFocus()
 
    def OnListEditionsClicked(self, event): # wxGlade: MainFrame.<event_handler>
        if not self.listEditions.GetSelection() == wx.NOT_FOUND:
            self.textEditedWord.ChangeValue(self.listEditions.GetStringSelection().split(' | ')[0])
            self.textEditionType.ChangeValue(self.listEditions.GetStringSelection().split(' | ')[1])

    def OnEditionMode(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy is None:
            if self.GetToolBar():
                self.GetToolBar().ToggleTool(ID_ED_MODE, False)
            return
        if not self.ed_mode:
            self.turnOnEdition()
        else:
            self.turnOffEdition()

    def OnMenuDocEdNextWord(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is None: return
        if not self.ed_mode:
            self.turnOnEdition()
            return
        
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_GRA:
            self.graphy_word_editing.setFocused(False)
            w = self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing)
            if w is not None:
                self.graphy_word_editing = w
                if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(w):
                    self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(w))
                self.turnOnEdition()
            else:
                self.turnOffEdition()
        elif self.notebook_1.GetCurrentPage().GetId() == ID_TAB_MOR:
            if self.morpho_seg_ii < (len(self.morpho_word_editing.getPartOfSpeech()) - 1):
                w = self.morpho_word_editing
                self.morpho_seg_ii += 1
            else:
                self.morpho_word_editing.setFocused(False)
                w = self.graphy.getTexts()[self.active_text].getNextWord(self.morpho_word_editing)
                while (w is not None and (not w.isRelevantToPOS() or w.getString().replace("_",'').strip() == "")):
                    w = self.graphy.getTexts()[self.active_text].getNextWord(w)
                self.morpho_seg_ii = 0
            if w is not None:
                self.morpho_word_editing = w
                if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(w):
                    self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(w))
                self.turnOnEdition()
            else:
                self.turnOffEdition()

    def turnOffEdition(self):
        '''
        Turn off the edition mode, caring all the operations needed.
        '''
        if self.ed_mode:
            if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_GRA and self.graphy_word_editing is not None:
                try:
                    self.graphy_word_editing.setFocused(False)
                    self.delightCell(self.graphy_text_html_window.GetInternalRepresentation(), self.graphy_word_editing.getId())
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                if self.GetToolBar():
                    self.GetToolBar().ToggleTool(ID_ED_MODE, False)
                self.ClearGraphyView()
                self.ed_mode = False
                #self.ReloadCurrentPage()
                #if self.cell_ref is not None: self.ReloadCurrentPage() #[ppff:08/09/09 - parece desnecessário...]
                if self.GetToolBar():
                    for tool_id in self.toolbar_ed:
                        self.GetToolBar().EnableTool(tool_id, False)
                for menu_it in self.MenuEditionToken.GetMenuItems():
                    menu_it.Enable(False)
                for menu_it in self.MenuEditionBreak.GetMenuItems():
                    menu_it.Enable(False)
            elif self.notebook_1.GetCurrentPage().GetId() == ID_TAB_MOR and self.morpho_word_editing is not None:
                try:
                    self.morpho_word_editing.setFocused(False)
                    self.delightCell(self.morpho_text_html_window.GetInternalRepresentation(),
                                     self.morpho_word_editing.getId()+':'+str(self.morpho_seg_ii))
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                if self.GetToolBar():
                    self.GetToolBar().ToggleTool(ID_ED_MODE, False)
                self.ClearMorphoView()
                self.ed_mode = False
                #self.ReloadCurrentPage()

    def turnOnEdition(self):
        '''
        Turn on the edition mode, caring all the operations needed.
        '''
        # If no word was previously under edition, select the first one
        if not self.ed_mode:
            self.ed_mode = True
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_GRA:
            if self.graphy_word_editing is None or\
                    not self.graphy_word_editing.getId() in self.graphy.getTexts()[self.active_text].words_id:
                self.graphy_word_editing = self.graphy.getTexts()[self.active_text].getPageWords(1)[0]
            if self.GetToolBar():
                for tool_id in self.toolbar_ed:
                    self.GetToolBar().EnableTool(tool_id, tool_id != ID_ED_REMOVE_BK or self.graphy_word_editing.getOriginalString('|').find('|') >= 0)
                self.GetToolBar().ToggleTool(ID_ED_MODE, True)
            # If the page was changed, select the first word of it
            if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(self.graphy_word_editing):
                self.graphy_word_editing.setFocused(False)
                self.graphy_word_editing = self.graphy.getTexts()[self.active_text].getPageWords(self.GetCurrentPageNumber())[0]
                self.ReloadCurrentPage()
            self.LoadGraphyWord(self.graphy, self.graphy_word_editing, self.graphy_word_editing.getId())
            self.highlightCell(self.graphy_text_html_window.GetInternalRepresentation(), self.graphy_word_editing.getId())
            self.scrollToCurrentCell()
            self.textEditionType.SetFocus()
            for menu_it in self.MenuEditionToken.GetMenuItems():
                menu_it.Enable(True)
            for menu_it in self.MenuEditionBreak.GetMenuItems():
                menu_it.Enable(True)
        elif self.notebook_1.GetCurrentPage().GetId() == ID_TAB_MOR:
            if self.morpho_word_editing is None or\
                    not self.morpho_word_editing.getId() in self.graphy.getTexts()[self.active_text].words_id:
                self.graphy_word_editing = self.graphy.getTexts()[self.active_text].getPageWords(1)[0]
                while (self.graphy_word_editing is not None and not self.graphy_word_editing.isRelevantToPOS()):
                    self.graphy_word_editing = self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing)
                self.morpho_word_editing = self.graphy_word_editing
                self.morpho_seg_ii = 0
                self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(self.morpho_word_editing))
            if self.GetToolBar():
                self.GetToolBar().ToggleTool(ID_ED_MODE, True)
            # If the page was changed, select the first word of it
            if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(self.morpho_word_editing):
                self.morpho_word_editing.setFocused(False)
                self.morpho_word_editing = self.graphy.getTexts()[self.active_text].getPageWords(self.GetCurrentPageNumber())[0]
                self.ReloadCurrentPage()
            self.LoadMorphoWord(self.morpho_word_editing, self.morpho_word_editing.getId())
            self.highlightCell(self.morpho_text_html_window.GetInternalRepresentation(),
                               self.morpho_word_editing.getId()+':'+str(self.morpho_seg_ii))
            self.scrollToCurrentCell()
            self.text_morpho_pos_fix.SetFocus()

    def scrollToCurrentCell(self):
        '''
        If the current cell is out of the window visible content, scroll the window.
        '''
        html_obj = self.graphy_text_html_window
        cell_obj = self.graphy_cell
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_MOR:
            html_obj = self.morpho_text_html_window
            cell_obj = self.morpho_cell
        if cell_obj is not None:
            scrolled_pixels = html_obj.GetViewStart()[1] * html_obj.GetScrollPixelsPerUnit()[1]
            if scrolled_pixels > (cell_obj.GetAbsPos().y + cell_obj.GetHeight()) or\
                    (scrolled_pixels + html_obj.GetScreenRect().GetHeight()) < (cell_obj.GetAbsPos().y + cell_obj.GetHeight()):
                html_obj.Scroll(-1, cell_obj.GetAbsPos().y / html_obj.GetScrollPixelsPerUnit()[1])

    def highlightCell(self, container, href):
        '''
        Search the HTML cells for the word being edited.
        '''
        html_obj = self.graphy_text_html_window
        cell_obj = self.graphy_cell
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_MOR:
            html_obj = self.morpho_text_html_window
            cell_obj = self.morpho_cell
        cell = container.GetFirstChild()
        while cell is not None:
            if isinstance(cell, wx.html.HtmlContainerCell):
                self.highlightCell(cell, href)
            if isinstance(cell, wx.html.HtmlWordCell) and\
                    cell.GetLink() and\
                    cell.GetLink().GetHref() == href:
                html_obj.Refresh()
                html_obj.SelectWord(cell.GetAbsPos())
                if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_MOR:
                    self.morpho_cell = cell
                else:
                    self.graphy_cell = cell
            cell = cell.GetNext()

    def delightCell(self, container, href):
        '''
        Search the HTML cells for the word being edited.
        '''
        pass
    
    def OnMenuDocEdPageNumber(self, event): # wxGlade: MainFrame.<event_handler>
        #self.OnMenuEdInsertPageNum(event)
        if not self.ed_mode:
            return
        p = self.graphy.getTexts()[self.active_text].getPreviousWord(self.graphy_word_editing,True)
        n = self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing,True)

        if p is None and n is None:
            wx.MessageBox(_(u'Não é possível transformar a única palavra do texto em número de página.'), _(u'E-Dictor'))
            return
        
        if not isinstance(self.graphy_word_editing.getParent().getParent().getParent(), SectionElement):
            is_footer = (p is not None) or (n is None)         
            if p is not None and n is not None:
                is_footer = wx.MessageDialog(self, _(u'O número de página se localiza no rodapé?'), _(u'E-Dictor'), wx.YES_NO | wx.YES_DEFAULT | wx.ICON_QUESTION).ShowModal() == wx.ID_YES
        else:
            is_footer = self.graphy_word_editing.getParent().getParent().getParent().getType() == 'footer'
            
        try:
            self.log(u'Log: [op:setWordAsPageNumber] [params:' + self.graphy_word_editing.getId() + ']\n')
            if self.graphy.getTexts()[self.active_text].setWordAsPageNumber(self.graphy_word_editing,\
                                                          is_footer, self.undo_stack, self.active_text, self.GetCurrentPageNumber()):
                self.redo_stack = []
                self.turnOffEdition()
                self.graphy.modified = True
                self.ReloadCurrentPage()
                self.graphy_word_editing = None
            self.SetStatusBarMessage('')
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            self.ErrorMessageDialog(msg, _(u"E-Dictor"))
            self.SetStatusBarMessage(msg)

    def OnMenuDocEdPrevWord(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is None: return
        if not self.ed_mode:
            self.turnOnEdition()
            return

        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_GRA:
            self.graphy_word_editing.setFocused(False)
            w = self.graphy.getTexts()[self.active_text].getPreviousWord(self.graphy_word_editing)
            if w is not None:
                self.graphy_word_editing = w
                if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(w):
                    self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(w))
                self.turnOnEdition()
            else:
                self.turnOffEdition()
        elif self.notebook_1.GetCurrentPage().GetId() == ID_TAB_MOR:
            if self.morpho_seg_ii > 0:
                w = self.morpho_word_editing
                self.morpho_seg_ii -= 1
            else:
                self.morpho_word_editing.setFocused(False)
                w = self.graphy.getTexts()[self.active_text].getPreviousWord(self.morpho_word_editing)
                while (w is not None and (not w.isRelevantToPOS() or w.getString().replace("_",'').strip() == "")):
                    w = self.graphy.getTexts()[self.active_text].getPreviousWord(w)
                if w is not None:
                    self.morpho_seg_ii = (len(w.getPartOfSpeech()) - 1)
                else:
                    self.morpho_seg_ii = 0 
            if w is not None:
                self.morpho_word_editing = w
                if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(w):
                    self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(w))
                self.turnOnEdition()
            else:
                self.turnOffEdition()

    def OnMenuDocEdInsertBreak(self, event): # wxGlade: MainFrame.<event_handler>
        if self.ed_mode:
            # Last word: no break insertion allowed
            if self.graphy_word_editing == self.graphy.getTexts()[self.active_text].getWordsList()[-1]:
                wx.MessageDialog(self, _(u'Na última palavra do texto, não é permitida a inserção de quebras.'), _(u'E-Dictor'), wx.ID_OK | wx.ICON_INFORMATION).ShowModal()
            # Check whether the word is inside a Sentence element
            if self.graphy_word_editing.getParent().node.tag != 's':
                wx.MessageDialog(self, _(u'A inserção de quebra é permitida apenas no interior de sentenças do texto.'), _(u'E-Dictor'), wx.ID_OK | wx.ICON_INFORMATION).ShowModal()
                return
            # Forbids two or more breaks per word 
            if self.graphy_word_editing.getOriginalString('|').find('|') >= 0 and \
                        not self.YesNoMessageDialog(_(u'Já há uma quebra nesta palavra. Se você continuar ela será substituída pela que você definir. Continua?'),_(u'E-Dictor')):
                return
            dialog = InsertBreakDialog(None)
            sep = '|'
            if self.graphy_word_editing.getOriginalString('|').find('|') >= 0:
                sep = ''
            dialog.setBreakString(self.graphy_word_editing.getOriginalString('|')+sep)
            if dialog.ShowModal() == wx.ID_OK:
                wx.BeginBusyCursor()
                try:
                    # Change word object
                    self.SetStatusBarMessage(_(u'Inserindo quebra...'))
                    self.log(u'Log: [op:insertBreak] [params:' + self.graphy_word_editing.getId() + ']\n')
                    self.graphy_word_editing.insertBreak(dialog.getBreakString(), dialog.getBreakType(),
                                                         dialog.getOptions(), dialog.getLineNr(), self.undo_stack, self.active_text,
                                                         self.GetCurrentPageNumber())
                    if dialog.getBreakType() == 'p':
                        self.graphy.getTexts()[self.active_text].processPages()
                    self.graphy.modified = True
                    self.redo_stack = []
                    self.ReloadCurrentPage()
                    self.turnOnEdition()
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                    wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
                wx.EndBusyCursor()
            dialog.Destroy()
        self.SetStatusBarMessage('')

    def OnMenuProgramPref(self, event): # wxGlade: MainFrame.<event_handler>
        dlg = PreferencesDialog(self)
        dlg.configDialog(self)
        dlg.ShowModal()
        if self.graphy_word_editing is not None:
            self.ReloadCurrentPage()

    def OnMenuProgramTests(self, event): # wxGlade: MainFrame.<event_handler>
        Test(self).runAllTests()

    def OnMenuDocEdRemoveWord(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is not None:
            if not self.test_mode and\
                    not self.YesNoMessageDialog(_(u"Confirma a exclusão desta palavra?"), _(u"E-Dictor")):
                return
            w = self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing, True)
            if w is None:
                w = self.graphy.getTexts()[self.active_text].getPreviousWord(self.graphy_word_editing, True)
            self.SetStatusBarMessage(_(u'Removendo a palavra selecionada...'))
            self.log(u'Log: [op:removeWord] [params:' + self.graphy_word_editing.getId() + ']\n')
            self.graphy.getTexts()[self.active_text].removeWord(self.graphy_word_editing, self.undo_stack, self.active_text,
                                                                self.GetCurrentPageNumber())
            self.redo_stack = []
            self.graphy.modified = True
            self.ReloadCurrentPage()
            # Place the edition in the previous word (or None if it was the first)
            self.graphy_word_editing = w
            self.turnOnEdition()            
        self.SetStatusBarMessage('')

    def OnMenuDocEdWordMoveForward(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is not None:
            self.log(u'Log: [op:moveWord] [params:' + self.graphy_word_editing.getId() + ', fw]\n')
            self.graphy_word_editing = self.graphy.getTexts()[self.active_text].moveWord(self.graphy_word_editing, True, self.undo_stack,
                                                                                         self.active_text, self.GetCurrentPageNumber())
            if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(self.graphy_word_editing):
                self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(self.graphy_word_editing))
            self.graphy.modified = True
            self.redo_stack = []
            self.ReloadCurrentPage()
            self.turnOnEdition()            

    def OnMenuDocEdWordMoveBack(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is not None:
            self.log(u'Log: [op:moveWord] [params:' + self.graphy_word_editing.getId() + ', back]\n')
            self.graphy_word_editing = self.graphy.getTexts()[self.active_text].moveWord(self.graphy_word_editing, False, self.undo_stack,
                                                                                         self.active_text, self.GetCurrentPageNumber())
            if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(self.graphy_word_editing):
                self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(self.graphy_word_editing))
            self.graphy.modified = True
            self.redo_stack = []
            self.ReloadCurrentPage()
            self.turnOnEdition()            

    def OnMenuDocEdInsertText(self, event): # wxGlade: MainFrame.<event_handler>
        if self.ed_mode:
            if isinstance(self.graphy_word_editing.getParent(), TextElement):
                wx.MessageBox(_(u'Não é permitido inserir texto dentro de um elemento do tipo Número de Página.'), _(u'E-Dictor'))
                return 
            dialog = InsertTextDialog(None)
            if dialog.ShowModal() == wx.ID_OK:
                self.log(u'Log: [op:insertText] [params:' + str(self.graphy_word_editing.getId()) + ', ' +\
                                           dialog.getEnteredText() + ', ' + str(dialog.getRadioSelection()) + ']\n')
                self.graphy_word_editing = self.graphy.getTexts()[self.active_text].insertText(self.graphy_word_editing, 
                                                                                               dialog.getEnteredText(), 
                                                                                               dialog.getRadioSelection(), 
                                                                                               self.undo_stack, self.active_text,
                                                                                               self.GetCurrentPageNumber())
                self.redo_stack = []
                self.graphy.modified = True
                self.ReloadCurrentPage()
                self.turnOnEdition()
        else:
            wx.MessageBox(_(u'É necessário selecionar um símbolo do texto para marcar o ponto de inserção.'), _(u'E-Dictor'))
        self.SetStatusBarMessage('')

    def OnMenuDocEdRemoveBreak(self, event): # wxGlade: MainFrame.<event_handler>
        if not self.test_mode and self.graphy_word_editing.getBreakType() == 'p' and \
                not self.YesNoMessageDialog(_(u"Os dados de cabeçalho e rodapé (se houver) serão perdidos. Continua?"), _(u"E-Dictor")):
            return 
        self.log(u'Log: [op:removeBreak] [params:' + self.graphy_word_editing.getId() + ']\n')
        if self.graphy_word_editing.removeBreak(self.undo_stack, self.active_text, self.GetCurrentPageNumber()):
            self.graphy.getTexts()[self.active_text].processPages()
            self.graphy.modified = True
            self.redo_stack = []
            self.ReloadCurrentPage()
            self.turnOnEdition()
        self.SetStatusBarMessage('')

    def OnMenuDocEdBreakSentence(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is not None and\
                not isinstance(self.graphy_word_editing.getParent(), TextElement) and\
                self.graphy_word_editing.getParent() == self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing).getParent():
            wx.BeginBusyCursor()
            try:
                self.log(u'Log: [op:breakSentence] [params:' + self.graphy_word_editing.getId() + ']\n')
                w_ret = self.graphy.getTexts()[self.active_text].breakSentence(self.graphy_word_editing, self.undo_stack, self.active_text,
                                                                               self.GetCurrentPageNumber())
                self.redo_stack = []
                if w_ret is not None:
                    self.graphy_word_editing = w_ret
                    self.graphy.modified = True
                    self.ReloadCurrentPage()
                    self.turnOnEdition()
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
            wx.EndBusyCursor()
        self.SetStatusBarMessage('')

    def OnMenuDocEdBreakParag(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is not None and\
                isinstance(self.graphy_word_editing.getParent().getParent(), Paragraph) and\
                self.graphy_word_editing.getParent().getParent() == self.graphy.getTexts()[self.active_text].getNextWord(self.graphy_word_editing).getParent().getParent():
            wx.BeginBusyCursor()
            try:
                self.log(u'Log: [op:breakParagraph] [params:' + self.graphy_word_editing.getId() + ']\n')
                self.graphy_word_editing = self.graphy.getTexts()[self.active_text].breakParagraph(self.graphy_word_editing, self.undo_stack,
                                                                                                   self.active_text, self.GetCurrentPageNumber())
                self.redo_stack = []
                self.graphy.modified = True
                self.ReloadCurrentPage()
                self.turnOnEdition()
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
            wx.EndBusyCursor()
        self.SetStatusBarMessage('')

    def OnMenuDocEdMeta(self, event): # wxGlade: MainFrame.<event_handler>
        if __builtin__.cfg.get(u'Preferences', u'Metadata') == u'':
            wx.MessageBox(_(u"Não há metadados definidos. Favor checar as Preferências da aplicação."), "E-Dictor")
            return
        if self.graphy is not None:
            dialog = MetadataDialog(None)
            dialog.setMetadata(self.graphy.getMetadata())
            if dialog.ShowModal() == wx.ID_OK:
                self.SetStatusBarMessage(_(u'Atualizando metadados...'))
                self.graphy.setMetadata(dialog.getMetadata())
                self.graphy.modified = True
        self.SetStatusBarMessage('')

    def OnMenuDocEdTextProperties(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy is not None:
            dialog = TextPropertiesDialog(None)
            if dialog.setElement(self.graphy.getTexts()[self.active_text]) and\
                    dialog.ShowModal() == wx.ID_OK:
                self.log(u'Log: [op:text-properties] [params:' + str(self.active_text) + ']\n')
                self.createDocumentTextsMenus()
                self.graphy.modified = True

    def OnMenuDocEdTextRemove(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy is None or len(self.graphy.getTexts()) == 1 or\
                not self.YesNoMessageDialog(_(u"Confirma a exclusão deste texto?"), _(u"E-Dictor")):
            return
        # Remove text object
        self.log(u'Log: [op:remove-text] [params:' + unicode(self.active_text) + ']\n')
        self.graphy.removeText(self.graphy.getTexts()[self.active_text], self.undo_stack, self.active_text,
                               self.GetCurrentPageNumber())
        self.redo_stack = []
        for k, v in self.menu_opts.iteritems():
            if self.active_text == v:
                del self.menu_opts[k]
                break
        self.active_text = 0
        self.createDocumentTextsMenus()
        for m in self.MenuDocSelText.GetMenuItems():
            if self.menu_opts[m.GetId()] == self.active_text:
                m.Check(True)
                break
        self.ReloadCurrentPage()
        self.graphy.modified = True
        
    def OnMenuFileImportXML(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy and not self.test_mode and not self.YesNoMessageDialog(_(u"Há uma estrutura XML em uso. Ela precisará ser descartada para a conversão. Continua?"), _(u"E-Dictor")):
            return
        wildcard = _(u"Arquivos XML (*.xml)|*.xml;*.XML|Todos arquivos (*.*)|*.*")
        dlg = wx.FileDialog(
            self, message=_(u"Importar arquivo"), defaultDir=os.getcwd(),
            defaultFile="", wildcard=wildcard, style=wx.OPEN | wx.CHANGE_DIR
            )
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            graphy = Graphy()
            wx.BeginBusyCursor()
            try:
                self.SetStatusBarMessage(_(u"Importando arquivo %s...")%path)
                graphy.importOldXML(path)
                self.graphy = graphy
                self.createDocumentTextsMenus()
                self.active_text = 0
                self.LoadPage(1)
                self.turnOffEdition()
                self.graphy_file_path = None
                if self.GetToolBar():
                    self.GetToolBar().EnableTool(ID_ED_MODE, True)
                    self.GetToolBar().EnableTool(ID_ED_PAGE_NUMBER, True)
                self.notebook_1.ChangeSelection(1)
                self.setAppTitle()
                for menu_it in self.MenuDocEdition.GetMenuItems():
                    menu_it.Enable(True)
                for menu_it in self.MenuDoc.GetMenuItems():
                    menu_it.Enable(True)
                self.MenuDocTxt2XML.Enable(False)
                self.SetStatusBarMessage(_(u"Arquivo %s importado.")%path)
                self.graphy.modified = True
                self.undo_stack = []
                self.redo_stack = []
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                self.ErrorMessageDialog(msg, _(u"Erro importando arquivo!"))
                self.SetStatusBarMessage(_(u"Erro importando arquivo!"))
            wx.EndBusyCursor()
        dlg.Destroy()

    def OnMenuDocEdHeadFoot(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy is None: return
        dialog = InsertTextDialog(None)
        dialog.setRadioButtonsLabel(_(u'Escolha uma opção:'),_(u'Cabeçalho'), _(u'Rodapé'))
        page_nr = self.GetCurrentPageNumber()

        # Get the current header/footer content [DESABILITADO: 12/11/11, Pablo]
#        h_text = u''
#        f_text = u''
#        if page_nr >= 2:
#            h_text = self.graphy.getTexts()[self.active_text].getPagesList()[self.GetCurrentPageNumber() - 2][2].getText(0)
#        else:
#            if self.graphy.getTexts()[self.active_text].getElements()[0].getPageHeader() is not None:
#                h_text = self.graphy.getTexts()[self.active_text].getElements()[0].getPageHeader().getText()
#        if page_nr < self.graphy.getTexts()[self.active_text].getLastPageNumber():
#            f_text = self.graphy.getTexts()[self.active_text].getPagesList()[self.GetCurrentPageNumber()-1][2].getText(1)
#        else:
#            if self.graphy.getTexts()[self.active_text].getElements()[-1].getPageFooter() is not None:
#                f_text = self.graphy.getTexts()[self.active_text].getElements()[-1].getPageFooter().getText()
#        
#        dialog.setRadioButtonsBoundText(h_text, f_text)
        
        if dialog.ShowModal() == wx.ID_OK:
            self.log(u'Log: [op:insertHeadFootText] [params:' + str(self.GetCurrentPageNumber()) + ', ' +\
                     dialog.getEnteredText() + ', ' + str(dialog.getRadioSelection()) + ']\n')
            if self.graphy.getTexts()[self.active_text].insertHeadFootText(\
                   self.GetCurrentPageNumber(),
                   dialog.getEnteredText(),
                   dialog.getRadioSelection(),
                   self.undo_stack, self.active_text, self.GetCurrentPageNumber()):
                self.redo_stack = []
                self.ReloadCurrentPage()
                self.graphy.modified = True
            self.SetStatusBarMessage(u'')

    def OnMenuDocEdUndo(self, event): # wxGlade: MainFrame.<event_handler>
        if len(self.undo_stack) > 0:
            # Undo last edition
            wx.BeginBusyCursor()
            try:
                self.SetStatusBarMessage(_(u'Desfazendo última edição...'))
                # Remove last edition from undo stack            
                undo_op = self.undo_stack.pop(0)
                if undo_op[0] == 'TEXT':
                    self.redo_stack.insert(0, ['TEXT',
                                               [self.text_ctrl_ocr.GetValue(), self.text_ctrl_ocr.GetInsertionPoint()],
                                               _('Refazer alteração do texto.')])
                    self.text_ctrl_ocr.ChangeValue(undo_op[1][0])
                    self.text_ctrl_ocr.SetInsertionPoint(undo_op[1][1])
                    self.text_ctrl_ocr.SetFocus()                    
                    self.prev_text_ocr = undo_op[1]
                else:
                    self.turnOffEdition()
                    self.log(u'Log: [op:undoEdition] [params:0, ' + undo_op[0] + ']\n')
                    if undo_op[0] != 'REMOVE_TEXT':
                        utext_obj = self.graphy.getTexts()[undo_op[-3]]
                    else:
                        # REMOVE-TEXT
                        utext_obj = undo_op[1]
                    ret = self.graphy.undoEdition(utext_obj, 0, self.redo_stack, undo_op, self)
                    if ret[0]:
                        self.active_text = undo_op[-3]
                        if undo_op[-2] != self.GetCurrentPageNumber():
                            self.GoToPageNumber(undo_op[-2])
                        else:
                            self.ReloadCurrentPage()
                        if ret[1] is not None:
                            self.graphy_word_editing = ret[1]
                            self.turnOnEdition()
                    else:
                        self.ErrorMessageDialog(ret[1], _(u'E-Dictor'))
                self.SetStatusBarMessage('')
                if len(self.undo_stack) == 0:
                    if self.graphy is not None:
                        self.graphy.modified = False
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_UNDO, False)
                    self.GetToolBar().SetToolLongHelp(ID_ED_UNDO, _(u'Nada a desfazer.'))
                else:
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_UNDO, True)
                    self.GetToolBar().SetToolLongHelp(ID_ED_UNDO, self.undo_stack[0][-1])
                if len(self.redo_stack) == 0:
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_REDO, False)
                    self.GetToolBar().SetToolLongHelp(ID_ED_REDO, _(u'Nada a refazer.'))
                else:
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_REDO, True)
                    self.GetToolBar().SetToolLongHelp(ID_ED_REDO, self.redo_stack[0][-1])
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
            wx.EndBusyCursor()

    def OnReproTextChange(self, event): # wxGlade: MainFrame.<event_handler>
        self.undo_stack.insert(0, ['TEXT', self.prev_text_ocr, _(u'Desfazer alteração do texto.')])
        self.redo_stack = []
        if self.GetToolBar():
            self.GetToolBar().EnableTool(ID_ED_UNDO, True)
            self.GetToolBar().SetToolLongHelp(ID_ED_UNDO, self.undo_stack[0][-1])
            self.GetToolBar().EnableTool(ID_ED_REDO, False)
            self.GetToolBar().SetToolLongHelp(ID_ED_REDO, _(u'Nada a refazer.'))
        self.prev_text_ocr = [self.text_ctrl_ocr.GetValue(),
                              self.text_ctrl_ocr.GetInsertionPoint()]
        self.txt_modified = True
        if self.auto_save and (time.time() - self.LAST_SAVE_TIME) >= 60:
            # Save by periods of at least 1 min
            self.SetStatusBarMessage(_(u'Salvando cópia automática...'))
            self.text_ctrl_ocr.SaveFile(self.auto_save_file)
            self.SetStatusBarMessage(u'')
            self.LAST_SAVE_TIME = time.time()

    def OnMenuFileNew(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy is not None and (not self.graphy.isModified() or\
                self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja prosseguir?"), _(u"E-Dictor"))):
            self.notebook_1_pane_1.Enable(True)
            self.notebook_1.ChangeSelection(0)
            self.turnOffEdition()
            self.closeFile()
            self.setAppTitle()
            self.text_ctrl_ocr.SetFocus()
        
    def OnMenuFileRevert(self, event): # wxGlade: MainFrame.<event_handler>
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_REP:
            if self.orig_ocr_text == self.text_ctrl_ocr.GetValue():
                self.SetStatusBarMessage(_(u"Nada a fazer."))
                return
            
            if self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja reverter o arquivo?"), _(u"E-Dictor")):
                path = self.repro_file_path
                self.closeFile()
                self.openTxtFile(path)
        else:
            if self.graphy is None or not self.graphy.isModified():
                self.SetStatusBarMessage(_(u"Nada a fazer."))
                return
            if self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja reverter o arquivo?"), _(u"E-Dictor")):
                path = self.graphy_file_path
                self.closeFile()
                pag_nr = self.GetCurrentPageNumber()
                self.openXMLFile(path)

    def OnMenuFilePrint(self, event): # wxGlade: MainFrame.<event_handler>
        dlg = wx.PrintDialog(self)
        if dlg.ShowModal() == wx.ID_OK:
            pass
        dlg.Destroy()

    def OnMenuFileExportPhono(self, event): # wxGlade: MainFrame.<event_handler>
        if not self.graphy:
            self.WarnMessageDialog(_(u"Nenhum dado para exportar."), _(u"Exportação cancelada"))
            self.SetStatusBarMessage(_(u"Nenhum dado para exportar."))
            return

        wildcard = _(u"Arquivos de texto (*.txt)|*.txt;*.TXT|") + _(u"Todos arquivos (*.*)|*.*")
        dir = os.getcwd()
        file_name = '*.txt'
        if self.graphy_file_path:
            dir = os.path.dirname(self.graphy_file_path)
            file_name = os.path.basename(self.graphy_file_path)
            root = os.path.splitext(file_name)[0]
            if root:
                file_name = root + '_fon.txt'
        dlg = wx.FileDialog(
            self, message=_(u"Exportar para arquivo"), defaultDir=dir,
            defaultFile=file_name, wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT
            )
        if dlg.ShowModal() == wx.ID_OK:
            try:
                path = dlg.GetPath()
                self.log(u'Log: [op:exportToTextFormat] [params:True,True]\n')
                exporting_data = self.graphy.getTexts()[self.active_text].exportToTextFormat(True, phonology=True)
                if not exporting_data:
                    msg = _(u"Não foi possível exportar os dados para análise fonológica.")
                    self.ErrorMessageDialog(msg, _(u"Erro exportando para arquivo!"))
                    self.SetStatusBarMessage(msg)
                with codecs.open(path, 'w', encoding='utf-8') as f:
                    f.write(exporting_data)
                self.SetStatusBarMessage(_(u"Dados exportados para '%s'.")%path)
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                self.ErrorMessageDialog(msg, _(u"Erro exportando para arquivo!"))
                self.SetStatusBarMessage(msg)
        dlg.Destroy()

    def OnMenuFileClose(self, event): # wxGlade: MainFrame.<event_handler>
        if ((self.graphy is not None and self.graphy.isModified()) or self.orig_ocr_text != self.text_ctrl_ocr.GetValue()) and\
                not self.YesNoMessageDialog(_(u"Há modificações não salvas que serão perdidas. Deseja prosseguir?"), _(u"E-Dictor")):
            return

        self.closeFile()
        self.notebook_1_pane_1.Enable(True)
        self.setAppTitle()
        self.SetStatusBarMessage('')
        
    def closeFile(self):
        self.log(u'Log: [op:closeFile] [params: txt:' + str(self.repro_file_path) + ', xml:' + str(self.graphy_file_path) + ']\n')
        
        # Repro TAB
        self.text_ctrl_ocr.ChangeValue('')
        self.repro_file_path = None
        self.txt_modified = False

        # XML/Morpho TAB
        self.turnOffEdition()
        self.graphy_text_html_window.SetPage('')
        self.morpho_text_html_window.SetPage('')
        for menu_it in self.MenuDocEdition.GetMenuItems():
            menu_it.Enable(False)
        for menu_it in self.MenuDoc.GetMenuItems():
            menu_it.Enable(False)
        self.MenuDocTxt2XML.Enable(True)

        # Remove temporary file (after crashes the system look for this file)
        if os.path.exists(self.auto_save_file):
            os.remove(self.auto_save_file)
            
        self.initVariables()

        if self.GetToolBar():
            self.GetToolBar().EnableTool(ID_ED_UNDO, False)
            self.GetToolBar().EnableTool(ID_ED_REDO, False)

    def OnMenuEditRedo(self, event): # wxGlade: MainFrame.<event_handler>
        if len(self.redo_stack) > 0:
            # Undo last edition
            wx.BeginBusyCursor()
            try:
                self.SetStatusBarMessage(_(u'Refazendo última operação...'))
                # Remove last edition from undo stack            
                redo_op = self.redo_stack.pop(0)
                if redo_op[0] == 'TEXT':
                    self.undo_stack.insert(0, ['TEXT',
                                               [self.text_ctrl_ocr.GetValue(), self.text_ctrl_ocr.GetInsertionPoint()],
                                               _(u'Desfazer alteração do texto.')])
                    self.text_ctrl_ocr.ChangeValue(redo_op[1][0])
                    self.text_ctrl_ocr.SetInsertionPoint(redo_op[1][1])
                    self.text_ctrl_ocr.SetFocus()                    
                    self.prev_text_ocr = redo_op[1]
                else:
                    self.turnOffEdition()
                    self.log(u'Log: [op:undoEdition] [params:1, ' + redo_op[0] + ']\n')
                    if redo_op[0] == 'REMOVE_TEXT':
                        redo_op[-3] -= 1
                    utext_obj = self.graphy.getTexts()[redo_op[-3]]
                    ret = self.graphy.undoEdition(utext_obj, 1, self.undo_stack, redo_op, self)
                    if ret[0]:
                        self.active_text = redo_op[-3]
                        if redo_op[-2] != self.GetCurrentPageNumber():
                            self.GoToPageNumber(redo_op[-2])
                        else:
                            self.ReloadCurrentPage()
                        if ret[1] is not None:
                            self.graphy_word_editing = ret[1]
                            self.turnOnEdition()
                    else:
                        self.ErrorMessageDialog(ret[1], _(u'E-Dictor'))
                self.SetStatusBarMessage('')
                if len(self.undo_stack) == 0:
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_UNDO, False)
                    self.GetToolBar().SetToolLongHelp(ID_ED_UNDO, _(u'Nada a desfazer.'))
                else:
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_UNDO, True)
                    self.GetToolBar().SetToolLongHelp(ID_ED_UNDO, self.undo_stack[0][-1])
                if len(self.redo_stack) == 0:
                    if self.graphy is not None:
                        self.graphy.modified = True
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_REDO, False)
                    self.GetToolBar().SetToolLongHelp(ID_ED_REDO, _(u'Nada a refazer.'))
                else:
                    if self.GetToolBar():
                        self.GetToolBar().EnableTool(ID_ED_REDO, True)
                    self.GetToolBar().SetToolLongHelp(ID_ED_REDO, self.redo_stack[0][-1])
            except:
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
            wx.EndBusyCursor()

    def OnMenuEditCut(self, event): # wxGlade: MainFrame.<event_handler>
        if isinstance(self.FindFocus(), wx.TextCtrl):
            self.FindFocus().Cut()
        
    def OnMenuEditCopy(self, event): # wxGlade: MainFrame.<event_handler>
        if isinstance(self.FindFocus(), wx.TextCtrl):
            self.FindFocus().Copy()

    def OnMenuEditPaste(self, event): # wxGlade: MainFrame.<event_handler>
        if isinstance(self.FindFocus(), wx.TextCtrl):
            self.FindFocus().Paste()

    def OnMenuEditSelectAll(self, event): # wxGlade: MainFrame.<event_handler>
        if isinstance(self.FindFocus(), wx.TextCtrl):
            self.FindFocus().SelectAll()

    def OnMenuEditFind(self, event): # wxGlade: MainFrame.<event_handler>
        self.find_dialog.configureDialog(self)
        self.find_dialog.ShowModal()

    def OnMenuEditFindNext(self, event): # wxGlade: MainFrame.<event_handler>
        if self.find_dialog.findNext():
            self.text_ctrl_ocr.SetSelection(self.find_dialog.sel_i, self.find_dialog.sel_f)

    def OnMenuEditFindPrevious(self, event): # wxGlade: MainFrame.<event_handler>
        if self.find_dialog.findPrevious():
            self.text_ctrl_ocr.SetSelection(self.find_dialog.sel_i, self.find_dialog.sel_f)

    def OnMenuShowToolbar(self, event): # wxGlade: MainFrame.<event_handler>
        if not self.MenuShowToolbar.IsChecked():
            self.SetToolBar(None)
            self.frame_main_toolbar.Hide()
        else:
            self.SetToolBar(self.frame_main_toolbar)
            self.frame_main_toolbar.Show()
            old_size = self.GetSize()
            self.SetSize((1030, 830))
            self.SetSize(old_size)
            if self.GetToolBar():
                for tool_id in self.toolbar_ed:
                    self.GetToolBar().EnableTool(tool_id, tool_id != ID_ED_REMOVE_BK or self.graphy_word_editing.getOriginalString('|').find('|') >= 0)

    def OnMenuHelpManual(self, event): # wxGlade: MainFrame.<event_handler>
        '''
        Call for a browser to show the HTML documentation.
        '''
        try:
            webbrowser.open(__builtin__.application_path + '/doc/index.html')
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Não foi possível abrir o manual!'), u'E-Dictor')

    def OnMenuHelpAbout(self, event): # wxGlade: MainFrame.<event_handler>
        dlg = AboutDialog(self)
        dlg.ShowModal()

    def OnMenuShowNextTab(self, event): # wxGlade: MainFrame.<event_handler>
        self.notebook_1.AdvanceSelection()

    def OnMenuShowPreviousTab(self, event): # wxGlade: MainFrame.<event_handler>
        self.notebook_1.AdvanceSelection(False)

    def OnApplyMorphoClick(self, event): # wxGlade: MainFrame.<event_handler>
        wx.BeginBusyCursor()
        try:
            if self.ed_mode and self.text_morpho_pos_fix.GetValue().strip() != '':
                w_list = [(self.morpho_word_editing, self.morpho_word_editing.node.__deepcopy__(False),
                           self.morpho_word_editing.getParent().getElements().index(self.morpho_word_editing),
                           self.morpho_word_editing.node.getparent().index(self.morpho_word_editing.node))]
                self.undo_stack.insert(0, ['W-EDIT', w_list, [], self.active_text, self.GetCurrentPageNumber(),
                                           _(u'Desfazer edição de palavra.')])
                if not self.ChangeMorphoWord(self.morpho_word_editing):
                    self.undo_stack.pop(0) # Cancel undo
                    wx.EndBusyCursor()
                    return

                # Replace All
                if self.checkbox_5.GetValue():
                    self.fg_all = True
                    self.SetStatusBarMessage(_(u'Atualizando as demais ocorrências de "%s"...')%self.morpho_word_editing.getString())
                    dup_list = self.graphy.getTexts()[self.active_text].getWordDuplicatesIDsList(self.morpho_word_editing)
                    dlg_rt = None
                    nr_repl = 0
                    for w_id in dup_list:
                        w = self.graphy.getTexts()[self.active_text].getWordByRef(w_id)
                        if w.getString() == self.morpho_word_editing.getString():  # Only words whose "final" versions are identical
                            if dlg_rt != wx.ID_REPLACE_ALL:
                                if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(w):
                                    self.LoadPage(self.graphy.getTexts()[self.active_text].getWordContainingPage(w), False)
                                else:
                                    self.LoadPage(self.GetCurrentPageNumber(), False)
                                self.highlightCell(self.morpho_text_html_window.GetInternalRepresentation(),
                                                   w.getId()+':'+str(self.morpho_seg_ii))
                                self.scrollToCurrentCell()
                                dlg_rt = self.ed_repl_dialog.ShowModal()
                            if dlg_rt == wx.ID_CANCEL: break
                            if dlg_rt != wx.ID_IGNORE: 
                                # Undo
                                self.undo_stack[0][1].append((w, w.node.__deepcopy__(False),
                                                              w.getParent().getElements().index(w), w.node.getparent().index(w.node)))
                                # Update
                                if not self.ChangeMorphoWord(w):
                                    self.undo_stack[0][1].pop(-1) # Cancel undo
                                else:
                                    nr_repl += 1

                if self.GetCurrentPageNumber() != self.graphy.getTexts()[self.active_text].getWordContainingPage(self.morpho_word_editing):
                    self.GoToPageNumber(self.graphy.getTexts()[self.active_text].getWordContainingPage(self.morpho_word_editing))
                else:
                    self.ReloadCurrentPage()

                self.morpho_word_editing.setFocused(True)
                self.OnMenuDocEdNextWord(None)
                self.graphy.modified = True

                if self.fg_all:
                    self.SetStatusBarMessage(unicode(nr_repl+1) + _(u' palavras atualizadas.'))

                self.fg_all = False
        except:
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')

        wx.EndBusyCursor()

    def OnMenuEdWordComment(self, event): # wxGlade: MainFrame.<event_handler>
        if self.graphy_word_editing is not None:
            dlg = CommentsDialog(self)
            dlg.setComments(self.graphy_word_editing.getId(), self.graphy_word_editing.getComments())
            if dlg.ShowModal() == wx.ID_OK:
                try:
                    self.log(u'Log: [op:setComments] [params:' + self.graphy_word_editing.getId() + ']\n')
                    self.graphy_word_editing.setComments(dlg.getComments())
                    self.graphy.modified = True
                    self.ReloadCurrentPage()
                    self.turnOnEdition()
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                    wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')

    def OnMenuDocComment(self, event): # wxGlade: MainFrame.<event_handler>
        '''
        Open dialog for comments about the entire text.
        '''
        el_obj = self.graphy.getTexts()[self.active_text]
        if el_obj is not None:
            dlg = CommentsDialog(self)
            dlg.setComments(el_obj.getId(), el_obj.getComments())
            if dlg.ShowModal() == wx.ID_OK:
                try:
                    self.log(u'Log: [op:setComments] [params:' + el_obj.getId() + ']\n')
                    el_obj.setComments(dlg.getComments())
                    self.graphy.modified = True
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                    wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')

    def log(self, msg):
        '''
        Save message in the log file and flush its data.
        '''
        if os.path.exists(__builtin__.user_data_path + "e-dictor.log") and\
                os.path.getsize(__builtin__.user_data_path + "e-dictor.log") > 500*1024:
            # This is to avoid a too big file
            __builtin__.log_file = open(__builtin__.user_data_path + "e-dictor.log", "w")
        else:
            __builtin__.log_file = open(__builtin__.user_data_path + "e-dictor.log", "a")
        __builtin__.log_file.write(("[ssid:" + str(SESSION_ID) + "] ").encode('utf-8') + msg.encode('utf-8'))
        __builtin__.log_file.close()
        
    def OnMenuEdWordApply(self, event): # wxGlade: MainFrame.<event_handler>
        self.OnBtnApplyChangesClicked(None)

    def OnMenuEdInsertPageNum(self, event): # wxGlade: MainFrame.<event_handler>
        dlg = InsertPNDialog(self)
        if dlg.ShowModal() == wx.ID_OK:
            self.log(u'Log: [op:InsertPageNum] [params:' + str(dlg.getPagePos()) + ',' + dlg.getPageNumber() + ']\n')
            if self.graphy.getTexts()[self.active_text].insertPageNumber(self.GetCurrentPageNumber(), dlg.getPagePos(), dlg.getPageNumber(),
                                                                         self.undo_stack, self.active_text):
                self.ReloadCurrentPage()
                self.graphy.modified = True
        dlg.Destroy()

    def OnMenuFileExportLex(self, event): # wxGlade: MainFrame.<event_handler>
        if not self.graphy:
            self.WarnMessageDialog(_(u"Nenhum dado para exportar."), _(u"Exportação cancelada"))
            self.SetStatusBarMessage(_(u"Nenhum dado para exportar."))
            return
        dlg = ExportLexDialog(self)
        if dlg.ShowModal() == wx.ID_OK:
            try: 
                self.log(u'Log: [op:exportLex] [params:' + dlg.getFileType() + ',' + str(dlg.getOptions()) + ']\n')
                doc_name = ''
                if self.graphy_file_path:
                    doc_name = os.path.splitext(os.path.basename(self.graphy_file_path))[0]
                wx.BeginBusyCursor()
                self.SetStatusBarMessage(_(u"Gerando conteúdo a ser exportado. Aguarde..."))
                content = self.graphy.getTexts()[self.active_text].exportLex(doc_name, dlg.getFileType(), dlg.getOptions())
                wx.EndBusyCursor()
                if content is not None:
                    # Save file
                    if dlg.getFileType().find("CSV") >= 0:
                        wildcard = _(u"Arquivos de texto (*.csv)|*.csv;*.CSV|") + _(u"Todos arquivos (*.*)|*.*")
                        file_ext = '.csv'
                        file_name = '*.csv'
                    else:
                        wildcard = _(u"Arquivos HTML (*.html)|*.html;*.HTML|") + _(u"Todos arquivos (*.*)|*.*")
                        file_ext = '.html'
                        file_name = '*.html'
                    dir = os.getcwd()
                    if self.graphy_file_path:
                        dir = os.path.dirname(self.graphy_file_path)
                        file_name = os.path.basename(self.graphy_file_path)
                        root = os.path.splitext(file_name)[0]
                        if root:
                            file_name = root + file_ext
                    dlg_file = wx.FileDialog(self, message=_(u"Exportar para arquivo"), defaultDir=dir,
                                             defaultFile=file_name, wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
                    if dlg_file.ShowModal() == wx.ID_OK:
                        try:
                            path = dlg_file.GetPath()
                            self.log(u'Log: [op:exportTextFormat] [params:False]\n')
                            with codecs.open(path, 'w', encoding='utf-8') as f:
                                f.write(content)
                            self.SetStatusBarMessage(_(u"Dados exportados para '%s'.")%path)
                        except:
                            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                            self.ErrorMessageDialog(msg, _(u"Erro exportando para arquivo!"))
                            self.SetStatusBarMessage(msg)
                    dlg_file.Destroy()
                else:
                    msg = _(u"Não foi possível exportar os dados.")
                    self.ErrorMessageDialog(msg, _(u"Erro exportando para arquivo!"))
                    self.SetStatusBarMessage(msg)
            except:
                wx.EndBusyCursor()
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
        dlg.Destroy()

    def OnMenuShowRaiseFont(self, event): # wxGlade: MainFrame.<event_handler>
        current_tab = self.notebook_1.GetCurrentPage().GetId()
        if current_tab == ID_TAB_REP:
            f = self.text_ctrl_ocr.GetFont()
            f.SetPointSize(f.GetPointSize() + 1)
            self.text_ctrl_ocr.SetFont(f)
            self.text_ctrl_ocr.Refresh()
            self.font_size_REP = self.text_ctrl_ocr.GetFont().GetPointSize()
        else:
            self.font_size_GRA += 1
            self.ReloadCurrentPage() 

    def OnMenuShowLowFont(self, event): # wxGlade: MainFrame.<event_handler>
        current_tab = self.notebook_1.GetCurrentPage().GetId()
        if current_tab == ID_TAB_REP:
            f = self.text_ctrl_ocr.GetFont()
            f.SetPointSize(f.GetPointSize() - 1)
            self.text_ctrl_ocr.SetFont(f)
            self.text_ctrl_ocr.Refresh()
            self.font_size_REP = f.GetPointSize()
        else:
            self.font_size_GRA -= 1
            self.ReloadCurrentPage() 

    def OnMenuDocTagging(self, event): # wxGlade: MainFrame.<event_handler>
        ''' Apply POS tags to the text. '''

        wx.MessageBox(_(u'Será feita a etiquetagem morfológica do texto. Isto pode levar vários minutos, por favor, aguarde.'), u'E-Dictor')
        
        try:
            self.log(u'Log: [op:OnMenuDocTagging]\n')

            wx.BeginBusyCursor()
            self.SetStatusBarMessage(_(u"Preparando texto para análise..."))
            # Create tokenized text to submit to tagger
            if os.name in ['posix','mac']:
                tag_os = 'posix'
                tag_cmd = 'utag'
                file_path = '/tmp/pos_'+str(SESSION_ID)+'.txt' 
            else:
                tag_os = 'win'
                tag_cmd = 'tag'
                if not os.path.exists('c:\\temp'):
                    os.mkdir('c:\\temp')
                file_path = 'c:\\temp\\pos_'+str(SESSION_ID)+'.txt'
                
            tmp_file = codecs.open(file_path, 'w', encoding='utf-8')
            eds = self.ed_types[1:self.ed_types.index(__builtin__.cfg.get(u'Preferences', u'POS_ed_level').decode('utf-8'))+1]
            eds.reverse()
            text = self.graphy.getTexts()[self.active_text].exportToWordTagFormat('', eds, [], False)
            text = text.rstrip('\n')
            text += '.\n' # To ensure tagger success
            tmp_file.write(text)
            tmp_file.close()
            
            self.SetStatusBarMessage(_(u"Executando o etiquetador..."))

            # Tagger execution
            if os.name in ['posix','mac']:
                p = subprocess.Popen(__builtin__.application_path + "/tagger/" + tag_os + "/vlmmtagger -" + tag_cmd + " " + file_path + " -l " +
                                     __builtin__.application_path + "/tagger/" + tag_os + "/model.vlmm", shell=True, 
                                      stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            else:
                p = subprocess.Popen('""' + __builtin__.application_path + '/tagger/' + tag_os + '/vlmmtagger" -' + tag_cmd + ' "' + file_path + '" -l "' +
                                     __builtin__.application_path + '/tagger/' + tag_os + '/model.vlmm"', shell=True,
                                     stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

            stdoutdata, stderrdata = p.communicate(None)
        
            if stdoutdata.find("Total time") >= 0 and \
                    os.path.exists(file_path + '.tagged'):
                self.SetStatusBarMessage(_(u"Importando etiquetas..."))
                text = ''
                with codecs.open(file_path + '.tagged', 'r', encoding='utf-8') as f:
                    text = f.read()
                # Identifies the edition type
                eds = self.ed_types[1:self.ed_types.index(__builtin__.cfg.get(u'Preferences', u'POS_ed_level').decode('utf-8'))+1]
                eds.reverse()
                ret, msg = self.graphy.getTexts()[self.active_text].importFromWordTagFormat(text, eds)
                self.graphy.modified = True
                if not ret:
                    self.SetStatusBarMessage(_(u"Erro importando de arquivo!"))
                    wx.MessageBox(msg, _(u"Erro importando de arquivo!"))
                else:
                    self.notebook_1.ChangeSelection(2)
                    self.ReloadCurrentPage()
                    wx.MessageBox(stdoutdata, _(u'E-Dictor') + ' : ' + _(u'Etiquetagem'))
                    self.SetStatusBarMessage(_(u"Etiquetagem completada com sucesso!"))
                os.remove(file_path + '.tagged')
            else:
                wx.MessageBox(stdoutdata + '\n' + stderrdata, _(u'Erro'))

            wx.EndBusyCursor()
            
        except OSError, e:
            wx.MessageBox(u'' + stderrdata.decode('iso-8859-1') + ". Execution failed: " + str(e) + '.', _(u'Erro'))
            wx.EndBusyCursor()

        except:
            wx.EndBusyCursor()
            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + stdoutdata + '\n' + stderrdata + '\n')
            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
            wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')

        # Exclude temporary text (and also the tagged) file
        if os.path.exists(file_path):
            os.remove(file_path)
       

    def OnMenuShowZoomIn(self, event): # wxGlade: MainFrame.<event_handler>
        if self.image_path != "":
            self.zoom += 3
            vpos = self.bmp_facsimile.GetScrollPos(wx.VSCROLL)
            hpos = self.bmp_facsimile.GetScrollPos(wx.HSCROLL)
            self.bmp_facsimile.SetPage('<img src="'+self.image_path+'" width="%d" height="%d" border=0/>' % 
                                       (int(self.image_size[0] * self.zoom/100), int(self.image_size[1] * self.zoom/100)))
            self.bmp_facsimile.SetScrollPos(wx.VSCROLL, vpos, True)
            self.bmp_facsimile.SetScrollPos(wx.HSCROLL, hpos, True)

    def OnMenuShowZoomOut(self, event): # wxGlade: MainFrame.<event_handler>
        if self.image_path != "":
            if self.zoom > 3:
                self.zoom -= 3
            vpos = self.bmp_facsimile.GetScrollPos(wx.VSCROLL)
            hpos = self.bmp_facsimile.GetScrollPos(wx.HSCROLL)
            self.bmp_facsimile.SetPage('<img src="'+self.image_path+'" width="%d" height="%d" border=0/>' % 
                                       (int(self.image_size[0] * self.zoom/100), int(self.image_size[1] * self.zoom/100)))
            self.bmp_facsimile.SetScrollPos(wx.VSCROLL, vpos, True)
            self.bmp_facsimile.SetScrollPos(wx.HSCROLL, hpos, True)

    def OnReprInsComment(self, event): # wxGlade: MainFrame.<event_handler>
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_REP and\
                self.notebook_1_pane_1.Enabled:
            dlg = CommentsDialog(self)
#            dlg.setComments('', '')
            if dlg.ShowModal() == wx.ID_OK:
                try:
                    self.log(u'Log: [op:ReprInsComment]\n')
                    pos = self.text_ctrl_ocr.GetInsertionPoint()
                    text = self.text_ctrl_ocr.GetValue()
                    str_comm = ''
                    for comm in dlg.getComments():
                        if not comm['remove']: 
                            str_comm += " @>comm:"+comm['author']+":"+comm['date']+":"+\
                                        comm['title']+":"+comm['text']+":<@ "
                    text =  text[:pos] + str_comm + text[pos:]
                    self.text_ctrl_ocr.SetValue(text)
                    self.text_ctrl_ocr.SetInsertionPoint(pos + len(str_comm))
                    self.text_ctrl_ocr.SetFocus()
                except:
                    msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                    self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                    traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                    wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')

    def OnReprInsPageBreak(self, event): # wxGlade: MainFrame.<event_handler>
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_REP and\
                self.notebook_1_pane_1.Enabled:
            self.log(u'Log: [op:ReprInsPageBreak]\n')
            pos = self.text_ctrl_ocr.GetInsertionPoint()
            text = self.text_ctrl_ocr.GetValue()
            text = text[:pos] + " @pag@ " + text[pos:] 
            self.text_ctrl_ocr.SetValue(text)
            self.text_ctrl_ocr.SetInsertionPoint(pos + 7)
            self.text_ctrl_ocr.SetFocus()

    def OnReprInsLineBreak(self, event): # wxGlade: MainFrame.<event_handler>
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_REP and\
                self.notebook_1_pane_1.Enabled:
            self.log(u'Log: [op:ReprInsLineBreak]\n')
            pos = self.text_ctrl_ocr.GetInsertionPoint()
            text = self.text_ctrl_ocr.GetValue()
            text = text[:pos] + " @ln@ " + text[pos:] 
            self.text_ctrl_ocr.SetValue(text)
            self.text_ctrl_ocr.SetInsertionPoint(pos + 7)
            self.text_ctrl_ocr.SetFocus()

    def OnReprInsColBreak(self, event): # wxGlade: MainFrame.<event_handler>
        if self.notebook_1.GetCurrentPage().GetId() == ID_TAB_REP and\
                self.notebook_1_pane_1.Enabled:
            self.log(u'Log: [op:ReprInsColBreak]\n')
            pos = self.text_ctrl_ocr.GetInsertionPoint()
            text = self.text_ctrl_ocr.GetValue()
            text = text[:pos] + " @col@ " + text[pos:] 
            self.text_ctrl_ocr.SetValue(text)
            self.text_ctrl_ocr.SetInsertionPoint(pos + 7)
            self.text_ctrl_ocr.SetFocus()

    def OnBtnDeleteAllClicked(self, event): # wxGlade: MainFrame.<event_handler>
        for ed in self.listEditions.GetItems():
            sel = ed.split(' | ')[1]
            t = self.ed_labels.index(sel)
            self.remove_list.append(self.ed_types[t])
            self.listEditions.Delete(self.listEditions.FindString(ed))
            self.textEditionType.Clear()
            self.textEditedWord.Clear()
            self.textEditionType.SetFocus()
            
#    def OnEditionTabKeyDown(self, event):
#        keycode = event.GetKeyCode()
#        controlDown = event.CmdDown()
#        altDown = event.AltDown()
#        shiftDown = event.ShiftDown()
# 
#        print keycode
#        if keycode == wx.WXK_SPACE:
#            print "you pressed the spacebar!"
#        elif controlDown and altDown:
#            print keycode
#        event.Skip()

    def OnMenuFileExportTags(self, event): # wxGlade: MainFrame.<event_handler>
        if not self.graphy:
            self.WarnMessageDialog(_(u"Nenhum dado para exportar."), _(u"Exportação cancelada"))
            self.SetStatusBarMessage(_(u"Nenhum dado para exportar."))
            return
        dlg = ExportTagsDialog(self)
        dlg.setEditionLabels(self.ed_labels[1:])
        if dlg.ShowModal() == wx.ID_OK:
            try: 
                self.log(u'Log: [op:exportTags] [params:' + dlg.getEditionLevel() + ',' + str(dlg.getOptions()) + ']\n')
                doc_name = 'file'
                if self.graphy_file_path:
                    doc_name = os.path.splitext(os.path.basename(self.graphy_file_path))[0]
                wx.BeginBusyCursor()
                self.SetStatusBarMessage(_(u"Gerando conteúdo a ser exportado. Aguarde..."))
                # Identifies the edition type
                pos = 0
                for ed in self.ed_labels: #__builtin__.cfg.get(u'Preferences', u'EditionTypes').decode('utf-8').split(','):
                    if ed == dlg.getEditionLevel():
                        break
                    pos += 1
                eds = self.ed_types[0:pos+1]
                eds.reverse()
                content = self.graphy.getTexts()[self.active_text].exportToWordTagFormat(doc_name,
                                eds, dlg.getOptions(), True)
                wx.EndBusyCursor()
                if content is not None:
                    wildcard = _(u"Arquivos de texto (*.txt)|*.txt;*.TXT|") + _(u"Todos arquivos (*.*)|*.*")
                    file_ext = '.txt'
                    dir = os.getcwd()
                    file_name = '*.txt'
                    if self.graphy_file_path:
                        dir = os.path.dirname(self.graphy_file_path)
                        file_name = os.path.basename(self.graphy_file_path)
                        root = os.path.splitext(file_name)[0]
                        if root:
                            file_name = root + file_ext
                    dlg_file = wx.FileDialog(self, message=_(u"Exportar para arquivo"), defaultDir=dir,
                                             defaultFile=file_name, wildcard=wildcard, style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT)
                    if dlg_file.ShowModal() == wx.ID_OK:
                        try:
                            path = dlg_file.GetPath()
                            self.log(u'Log: [op:exportTextFormat] [params:False]\n')
                            with codecs.open(path, 'w', encoding='utf-8') as f:
                                f.write(content.replace('{XML}',doc_name))
                            self.SetStatusBarMessage(_(u"Dados exportados para '%s'.")%path)
                        except:
                            msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                            self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                            traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                            self.ErrorMessageDialog(msg, _(u"Erro exportando para arquivo!"))
                            self.SetStatusBarMessage(msg)
                    dlg_file.Destroy()
                else:
                    msg = _(u"Não foi possível exportar os dados.")
                    self.ErrorMessageDialog(msg, _(u"Erro ao exportar para arquivo!"))
                    self.SetStatusBarMessage(msg)
            except:
                wx.EndBusyCursor()
                msg = str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n' + str(sys.exc_info()[2])
                self.log(str(sys.exc_info()[0]) + ':' + str(sys.exc_info()[1]) + '\n')
                traceback.print_tb(sys.exc_info()[2], None, open(__builtin__.log_file.name, "a"))
                wx.MessageBox(_(u'Operação não pode ser executada!'), u'E-Dictor')
        dlg.Destroy()

    def OnCboShowNivelEdClick(self, event): # wxGlade: MainFrame.<event_handler>
        self.ReloadCurrentPage()

# end of class MainFrame
